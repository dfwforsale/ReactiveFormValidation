{"version":3,"file":"validationInterop.bundle.js","mappings":"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A;AACA;AACA;AACA,sCAAsC,+CAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACO;AACP,sCAAsC,mCAAmC;AACzE;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,iBAAiB,aAAa,iBAAiB,WAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sCAAsC,sCAAsC;AAC5E;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sCAAsC,iBAAiB;AACvD;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sCAAsC,mDAAmD;AACzF;AACA,eAAe,QAAQ;AACvB,eAAe,mBAAmB,eAAe,4CAA4C;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sCAAsC,gDAAgD;AACtF;AACA,eAAe,QAAQ;AACvB,eAAe,mBAAmB,eAAe,4CAA4C;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sCAAsC,qDAAqD;AAC3F;AACA,eAAe,QAAQ;AACvB,eAAe,mBAAmB,eAAe,4CAA4C;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sCAAsC,0DAA0D;AAChG;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sCAAsC,yCAAyC;AAC/E;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;;;;;;;ACrIA;AACA;AAC+D;AACP;AACnB;AAC4B;AAC1D,8BAA8B,mDAAU;AAC/C;AACA;AACA;AACA;AACA;AACA,4CAA4C,4CAAQ;AACpD;AACA;AACA,gCAAgC,KAAyC,GAAG,iDAAuB,GAAG,CAAO;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qDAAa;AACtD;AACA;AACA;AACA;AACA,gCAAgC,KAAyC,GAAG,iDAAuB,GAAG,CAAO;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ;AACzC,4BAA4B,iDAAY;AACxC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAa;AAC7B;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,sCAAsC,EAAE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAS;AAC/B;AACA;AACA;AACA,mBAAmB,qDAAY;AAC/B;AACA;AACA;AACA,YAAY,4CAAQ;AACpB;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;;;;;AC3JA;AACA;AACwD;AAChB;AACxC;AACO;AACP;AACA;AACA,eAAe,iEAAiB;AAChC;AACA;AACA;AACA;AACA,YAAY,qDAAa;AACzB;AACA;AACA,sDAAsD,iEAAiB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,iEAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iEAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;AClDA;AACA;AACO;AACP;AACA;AACA;AACA,uC;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;;;;;;;;;;;;;AC9CA;AACA;AACgE;AACR;AAC4H;AAC/I;AAC4B;AACH;AACU;AACE;AAChB;AAC1D;AACA;AACO;AACP,iCAAiC;AACjC;AACA;AACA;AACA,QAAQ,uCAAG;AACX,uBAAuB,oDAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAQ,WAAW,UAAc;AAC7C;AACA;AACA,gCAAgC,KAAyC,GAAG,iDAAuB,GAAG,CAAO;AAC7G;AACA;AACA;AACA,aAAa,4CAAQ;AACrB;AACA;AACA,iBAAiB,4CAAQ;AACzB;AACA;AACA;AACA;AACA,aAAa,4CAAQ;AACrB;AACA;AACA,iBAAiB,4CAAQ;AACzB;AACA;AACA;AACA;AACA,+BAA+B,yEAAqB,2BAA2B,iEAAiB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uDAAc;AACzD,QAAQ,uCAAG,sBAAsB,uDAAc;AAC/C,yBAAyB,8CAAQ,qDAAqD,uDAAc,iBAAiB;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA,sCAAsC,+CAAU;AAChD;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC,sCAAsC,+CAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,uCAAuC,MAAM;AAClF;AACA;AACA;AACA,6BAA6B,8CAAQ,uCAAuC,MAAM;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,wDAAwD,EAAE;AACnG;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,0DAAiB;AACjE;AACA,8DAA8D,0DAAiB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,0CAA0C,uEAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0DAAkB;AAChD;AACA;AACA,yBAAyB,8CAAQ,wCAAwC,aAAa;AACtF;AACA;AACA;AACA,2BAA2B,sCAAsC;AACjE;AACA;AACA,aAAa;AACb;AACA,mGAAmG,oBAAoB;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qEAAgC;AAC1E;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAS;AACtC;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC,sCAAsC,qEAAgC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,gBAAgB;AACnF;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAAQ,0CAA0C,mBAAmB,KAAK,GAAG;AAClH;AACA,iDAAiD,gEAA2B,IAAI,oBAAoB,UAAU,GAAG,GAAG,0DAAiB;AACrI;AACA;AACA,yCAAyC,8CAAQ;AACjD,kDAAkD,+CAAU;AAC5D;AACA;AACA;AACA;AACA;AACA,sCAAsC,oDAAe,0EAA0E,8BAA8B;AAC7J;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAiB;AAClC;AACA;AACA;AACA,2BAA2B,mEAAkB,gJAAgJ;AAC7L,iBAAiB,0DAAiB;AAClC;AACA;AACA;AACA,2BAA2B,iFAAyB;AACpD,iBAAiB,0DAAiB;AAClC,2BAA2B,uEAAoB;AAC/C;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAiB;AAC3C;AACA,6BAA6B,8CAAQ,+BAA+B,mBAAmB;AACvF,oDAAoD,mBAAmB;AACvE;AACA;AACA;AACA,4EAA4E,uDAAc;AAC1F;AACA,uCAAuC,0DAAiB;AACxD,uCAAuC,0DAAiB;AACxD,yCAAyC,8CAAQ,+BAA+B,0DAAiB,YAAY;AAC7G,mCAAmC,8DAAyB,KAAK,0DAAiB,YAAY;AAC9F;AACA;AACA,yCAAyC,8CAAQ,gCAAgC,0DAAiB,YAAY;AAC9G;AACA,oEAAoE,0DAAiB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAAQ,+BAA+B,0DAAiB,YAAY,+DAA+D,uDAAc,0BAA0B;AAChN,yCAAyC,0DAAiB,YAAY,qBAAqB,uDAAc,0BAA0B;AACnI;AACA;AACA;AACA,iCAAiC,8CAAQ,+BAA+B,0DAAiB,YAAY;AACrG,2BAA2B,2DAAsB,KAAK,0DAAiB,YAAY;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAQ,yCAAyC,MAAM,0BAA0B,sBAAsB;AAChI;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,iDAAiD,MAAM;AAC5F;AACA;AACA;AACA,6BAA6B,8CAAQ,mDAAmD,MAAM;AAC9F,6DAA6D,MAAM;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,+CAA+C,MAAM;AAC1F;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA,iCAAiC,8CAAQ,kDAAkD,EAAE;AAC7F,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,kCAAkC,MAAM,iBAAiB,EAAE;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4CAAQ;AACrB,+CAA+C,IAAI;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAQ,8BAA8B,IAAI,QAAQ,UAAU;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,uBAAuB,kBAAkB,cAAc;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;;;;;;;;;;;ACzjBA;AACA;AACwD;AAClB;AACO;AACR;AACD;AACoB;AACR;AAChD;AACA;AACA;AACA,wCAAwC,qBAAqB;AACtD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA,QAAQ,uCAAG;AACX,QAAQ,uCAAG;AACX,QAAQ,uCAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iEAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,MAAM,sDAAW,OAAO;AACxF;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAQ;AACjC;AACA;AACA,gBAAgB,4CAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA,6BAA6B,8CAAQ,wEAAwE,EAAE;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA,6BAA6B,8CAAQ,oCAAoC,oBAAoB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yDAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,4CAA4C,EAAE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,sCAAsC,MAAM;AACjF;AACA;AACA;AACA,6BAA6B,8CAAQ,uCAAuC,MAAM;AAClF;AACA;AACA;AACA;AACA,yBAAyB,8CAAQ;AACjC;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+CAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAAO;AACnC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,sDAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sDAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,qBAAqB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sDAAW;AACpC;AACA;AACA,6CAA6C,8CAAQ,6CAA6C,sDAAc,IAAI;AACpH,yBAAyB;AACzB;AACA,yBAAyB,sDAAW;AACpC,yBAAyB,sDAAW;AACpC;AACA;AACA,iDAAiD,sDAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,8CAAQ,wCAAwC,sDAAc,IAAI;AACnH;AACA;AACA;AACA;AACA,yBAAyB,sDAAW;AACpC;AACA;AACA,yBAAyB,sDAAW;AACpC,yCAAyC,8CAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sDAAW;AACpC;AACA;AACA;AACA;AACA,yBAAyB,sDAAW;AACpC;AACA;AACA;AACA;AACA;AACA,yCAAyC,8CAAQ,mCAAmC,aAAa;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,6CAA6C,WAAW;AAC7F;AACA;AACA,iCAAiC,8CAAQ,kCAAkC,WAAW,8BAA8B,+BAA+B;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAAQ,0CAA0C,WAAW;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,sCAAsC,WAAW,iBAAiB,EAAE;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,UAAU;AAC/G;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,kCAAkC,WAAW,8BAA8B,+BAA+B;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,6BAA6B,WAAW;AACjF;AACA;AACA;AACA;AACA,yBAAyB,8CAAQ,0CAA0C,MAAM,0BAA0B,sBAAsB;AACjI;AACA,gFAAgF,+CAAU;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,kDAAkD,MAAM,iBAAiB,EAAE;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,2DAA2D,MAAM;AACtG;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,yDAAyD,MAAM,iBAAiB,EAAE;AAC3H;AACA;AACA;AACA,iCAAiC,8CAAQ;AACzC;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,0CAA0C,2BAA2B,gBAAgB,gBAAgB;AAC1I;AACA;AACA,aAAa;AACb;AACA;AACA,iCAAiC,8CAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,yCAAyC,8CAAQ,+DAA+D,+BAA+B,eAAe,EAAE;AAChK;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,4DAA4D,EAAE;AACvG;AACA,qCAAqC,8CAAQ,oCAAoC,sBAAsB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAQ,6DAA6D,iCAAiC,SAAS,2BAA2B;AACnK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,6BAA6B,8CAAQ,qDAAqD,mBAAmB,IAAI,oBAAoB,iBAAiB,EAAE;AACxJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,gDAAgD,MAAM,iBAAiB,sDAAc,IAAI;AAClI;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAW;AAC7B;AACA;AACA;AACA,iBAAiB,MAAM,sDAAW;AAClC;AACA;AACA,yC;;;;;;;;;;;;;;;;;;;;;AC16BA;AACA;AACkE;AAChB;AACF;AACX;AACe;AACb;AACM;AAC7C;AACA,WAAW,8CAAQ;AACnB,WAAW,8CAAQ;AACnB,UAAU,8CAAQ;AAClB,iBAAiB,8CAAQ;AACzB,UAAU,8CAAQ;AAClB,aAAa,8CAAQ;AACrB,WAAW,8CAAQ;AACnB,cAAc,8CAAQ;AACtB,UAAU,8CAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,KAAK;AACnD;AACA;AACA,+BAA+B,wCAAwC;AAChE;AACP;AACA,QAAQ,uCAAG;AACX;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAa;AAC3C;AACA;AACA,8BAA8B,iDAAa;AAC3C;AACA;AACA;AACA;AACA,QAAQ,uCAAG;AACX,QAAQ,uCAAG;AACX;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wCAAwC;AAChE;AACA,eAAe,cAAc,cAAc,uCAAuC;AAClF;AACA;AACA,QAAQ,uCAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2EAAsB;AAC7D;AACA;AACA,uCAAuC,2EAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAoE,SAAS,uCAAuC;AACxI;AACA,qBAAqB,+CAA+C;AACpE;AACA;AACA,QAAQ,uCAAG;AACX;AACA;AACA;AACA,oBAAoB,wEAAwE,SAAS,uCAAuC;AAC5I;AACA,qBAAqB,+CAA+C;AACpE;AACA;AACA,QAAQ,uCAAG;AACX;AACA;AACA;AACA;AACA;AACA,qBAAqB,+CAA+C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wCAAwC;AAC3D;AACA,iBAAiB,eAAe,gBAAgB,uCAAuC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAc;AAC7C,eAAe,yDAAa,mCAAmC,gDAAU,gCAAgC,6DAAe;AACxH;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;;;AC/IA;AACA;AACA;AACO;AACP;AACA,2EAA2E,4CAA4C;AACvH;AACA,0EAA0E,4CAA4C;AACtH;AACA,0EAA0E,4CAA4C;AACtH;AACA,iFAAiF,kDAAkD;AACnI;AACA,iFAAiF,kDAAkD;AACnI;AACA,oEAAoE,sCAAsC;AAC1G;AACA,qEAAqE,uCAAuC;AAC5G;AACA;AACA;AACA,CAAC,kCAAkC;AACnC,wC;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B,mC;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC,sC;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AAC6C;AACR;AACS;AACP;AACiB;AACxD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAc;AAC5C;AACA,6BAA6B,qCAAqC;AAClE;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAAU;AAC/B;AACA;AACA,yBAAyB,iEAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sDAAW;AAChC;AACA;AACA,qBAAqB,sDAAW;AAChC;AACA;AACA,qBAAqB,sDAAW;AAChC;AACA;AACA,qBAAqB,sDAAW;AAChC;AACA;AACA,qBAAqB,sDAAW;AAChC;AACA;AACA,qBAAqB,sDAAW;AAChC;AACA;AACA,qBAAqB,sDAAW;AAChC;AACA;AACA;AACA;AACA,+BAA+B,8CAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qCAAqC;AACnE;AACA,eAAe,YAAY;AAC3B,iBAAiB,QAAQ;AACzB;AACA;AACA,eAAe,iEAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;;;ACtHA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oCAAoC;AACvE;AACA,mC;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACoD;AACD;AACd;AACS;AACgC;AAC9E;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6DAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uCAAG;AACX,QAAQ,uCAAG;AACX,QAAQ,uCAAG,sBAAsB,uDAAc;AAC/C;AACA,yBAAyB,8CAAQ;AACjC;AACA,+BAA+B,uDAAc;AAC7C;AACA;AACA;AACA,8BAA8B,0DAAkB;AAChD,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uDAAc;AAC7C;AACA;AACA;AACA;AACA,2BAA2B,IAAI,KAAK,WAAW;AAC/C,yBAAyB,8CAAQ,4CAA4C,QAAQ;AACrF;AACA;AACA,6BAA6B,8CAAQ,6DAA6D,oBAAoB;AACtH;AACA,mCAAmC,8CAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,IAAI,KAAK,WAAW;AAC3D,qCAAqC,8CAAQ,4CAA4C,QAAQ;AACjG;AACA;AACA,yCAAyC,8CAAQ;AACjD;AACA;AACA;AACA,yCAAyC,8CAAQ,6DAA6D,oBAAoB;AAClI;AACA,+CAA+C,8CAAS;AACxD;AACA;AACA;AACA;AACA;AACA,6CAA6C,8CAAQ,kDAAkD,qDAAa,oDAAoD;AACxK;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,8CAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8CAAQ,gEAAgE,UAAU;AAC3H;AACA;AACA,yCAAyC,iDAAY;AACrD;AACA,6CAA6C,8CAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAW;AAC1B;AACA;AACA,yBAAyB,8CAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ,6DAA6D,UAAU;AAC5G;AACA,kCAAkC,0DAAkB;AACpD;AACA;AACA,2BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAAS;AAC9C;AACA,yCAAyC,8CAAQ;AACjD;AACA;AACA,yCAAyC,8CAAQ,mEAAmE,MAAM;AAC1H;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ;AACzC;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAQ;AACrC;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;;;;;ACtLA;AACA;AAC6C;AACL;AACxC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA,oBAAoB,qDAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sDAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,MAAM,sDAAW,uBAAuB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sDAAW;AAC5B,iBAAiB,sDAAW;AAC5B,iBAAiB,sDAAW;AAC5B,iBAAiB,sDAAW;AAC5B,iBAAiB,sDAAW;AAC5B;AACA,iBAAiB,sDAAW;AAC5B,iBAAiB,sDAAW;AAC5B,iBAAiB,sDAAW;AAC5B,iBAAiB,sDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,MAAM,sDAAW,kDAAkD;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;;;;;;ACjMA;AACA;AACqC;AACS;AAC0C;AACxF;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uCAAG;AACX,QAAQ,uCAAG;AACX,QAAQ,uCAAG,sBAAsB,uDAAc;AAC/C,yBAAyB,8CAAQ;AACjC;AACA;AACA;AACA,wEAAwE,sCAAsC;AAC9G;AACA;AACA;AACA,mCAAmC,uDAAc;AACjD;AACA;AACA;AACA;AACA,gBAAgB,4CAAQ,cAAc,4CAAQ;AAC9C,mEAAmE,gDAAgD;AACnH;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0DAAkB;AACxD;AACA,mEAAmE,2DAA2D,wCAAwC;AACtK;AACA;AACA;AACA;AACA;AACA,6CAA6C,8CAAQ,0CAA0C,qDAAa,0CAA0C;AACtJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAAQ,kCAAkC,UAAU;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qD;;;;;;;;;;;;;;;ACtGA;AACA;AAC8C;AAC9C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAmB;AACtC;AACA;AACA,mC;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,OAAO,EAAE,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACqC;AACE;AACvC;AACA;AACO;AACP;AACO;AACP;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA,uCAAuC,MAAM,SAAS,IAAI;AAC1D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,0CAA0C,gBAAgB;AAC1D;AACA,qCAAqC,wBAAwB;AAC7D;AACA;AACA;AACA,0CAA0C,YAAY;AACtD;AACA,qCAAqC,KAAK;AAC1C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI,EAAE,kBAAkB;AAC5C,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,8CAAQ,YAAY,eAAe,2BAA2B,kDAAkD;AAC/H;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA,KAAK;AACL,eAAe,8CAAQ,YAAY,eAAe,gDAAgD,oBAAoB;AACtH;AACA;AACO;AACP;AACA,iCAAiC,8CAAQ;AACzC;AACA;AACA,eAAe,gDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB,IAAI,8CAAQ,WAAW,IAAI,QAAQ;AACxF;AACA,qBAAqB,8CAAQ;AAC7B,qBAAqB,8CAAQ;AAC7B;AACA;AACA,qBAAqB,8CAAQ;AAC7B;AACA;AACA,qBAAqB,8CAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wDAAwD,oBAAoB,WAAW;AACvF;AACA;AACA,oBAAoB,iBAAiB,GAAG,iBAAiB;AACzD,sBAAsB,UAAU;AAChC;AACA,wBAAwB,KAAK;AAC7B;AACA;AACA,kCAAkC;AAClC;AACA,oBAAoB,QAAQ;AAC5B;AACA,wBAAwB,EAAE,eAAe;AACzC;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,EAAE;AAChB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAM;AACrB,eAAe,qBAAM;AACrB;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;ACvPA;AACA;AAC4C;AACP;AACS;AAC6B;AAC3E;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uCAAG;AACX,QAAQ,uCAAG;AACX,QAAQ,uCAAG,sBAAsB,uDAAc;AAC/C,yBAAyB,8CAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAQ,WAAW,4CAAQ;AAC3C;AACA,sCAAsC,0DAAkB;AACxD;AACA;AACA,4BAA4B,qDAAW,4BAA4B,MAAM;AACzE;AACA;AACA,4BAA4B,qDAAW;AACvC;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA,gFAAgF,0BAA0B;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uDAAc;AACjD;AACA;AACA;AACA,iCAAiC,8CAAQ,wCAAwC,IAAI;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAQ,wCAAwC,MAAM;AACvF;AACA;AACA,iCAAiC,8CAAQ,iDAAiD,qDAAa,wCAAwC;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,6BAA6B,8CAAQ,gDAAgD,qDAAa,gCAAgC;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAQ;AACjC;AACA;AACA,6EAA6E,YAAY,GAAG,kCAAkC;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;;;;;;;AC1JA;AACA;AAC+D;AACP;AACnB;AACG;AACjC,4BAA4B,mDAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+CAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qDAAa;AACjC;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAY;AAC5C;AACA;AACA,+BAA+B,8CAAS;AACxC;AACA;AACA;AACA,iCAAiC,8CAAQ,sCAAsC,WAAW,IAAI,eAAe;AAC7G,2BAA2B,8CAAS;AACpC;AACA;AACA,iCAAiC,8CAAQ;AACzC,2BAA2B,iDAAY;AACvC;AACA;AACA,SAAS;AACT;AACA;AACA,yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClFiU;AACjU;;;;;;;;;;;ACDA;AACA;AACA,gEAAgE;AAChE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAM,gBAAgB,qBAAM;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,kDAAkD;AACvG;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,qDAAqD,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE,8BAA8B,gBAAgB,kBAAkB;AAChE;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,oCAAoC,wBAAwB,iBAAiB;AAC7E,oCAAoC,wBAAwB,IAAI;AAChE;AACA,wCAAwC;AACxC,wCAAwC,oBAAoB;AAC5D;AACA,wCAAwC;AACxC,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uBAAuB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,0BAA0B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2BAA2B;AAClE;AACA;AACA,iBAAiB;AACjB,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,qDAAqD;AACrD,sDAAsD;AACtD,4DAA4D;AAC5D,8DAA8D;AAC9D;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wBAAwB;AAC/D;AACA;AACA,iBAAiB;AACjB,uDAAuD;AACvD,uDAAuD;AACvD,0DAA0D;AAC1D,oDAAoD;AACpD,mDAAmD;AACnD,qDAAqD;AACrD,sDAAsD;AACtD,4DAA4D;AAC5D,8DAA8D;AAC9D;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,yBAAyB;AACtF;AACA;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oBAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,0BAA0B;;;;;;;SCt4C3B;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;;;;UCtBA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA,E;;;;;UCPA;UACA;UACA;UACA;UACA,GAAG;UACH;UACA;UACA,CAAC,I;;;;;UCPD,wF;;;;;UCAA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D,E;;;;;;;;;;;;;ACNyE;AAEZ;AAE7D,MAAM,WAAW,GAAG,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAoB,CAAC;AAC/E,MAAM,OAAO,GAAG,iFAAS,CAAC,GAAG,CAA4B,sEAAc,CAAC,wBAAwB,CAAC,CAAC;AAClG,MAAM,KAAK,GAAG,OAAO,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;AAEhD,WAAW,CAAC,gBAAgB,CAAC,QAAQ,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;IACjD,CAAC,CAAC,cAAc,EAAE,CAAC;IACnB,MAAM,OAAO,GAAG,MAAM,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;IAClD,OAAO,CAAC,GAAG,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;AACtC,CAAC,CAAC,CAAC","sources":["webpack:///../Core/Builders/ReactiveFormBuilder.ts","webpack:///../Core/DependencyInjection/container-config.ts","webpack:///../Core/Factory/AsyncValidationFactory.ts","webpack:///../Core/Factory/FormControlFactory.ts","webpack:///../Core/Factory/FormGroupFactory.ts","webpack:///../Core/Factory/ReactiveFormControlFactory.ts","webpack:///../Core/Factory/ValidatorFactory.ts","webpack:///../Core/FormControl/ReactiveFormControl.ts","webpack:///../Core/FormGroup/ReactiveFormGroup.ts","webpack:///../Core/Handlers/HttpValidationHandler.ts","webpack:///../Core/Handlers/SignalRValidationHandler.ts","webpack:///../Core/Providers/FormStateProvider.ts","webpack:///../Core/Providers/SignalRConnectionProvider.ts","webpack:///../Core/Types/ContainerTypes.ts","webpack:///../Core/Utils/Debounce.ts","webpack:///../Core/Utils/SimpleSubject.ts","webpack:///../Core/Validators/RequiredValidator.ts","webpack:///../Services/FormParserService.ts","webpack:///../Services/ReactiveFormService.ts","webpack:///../Services/ReactiveValidatorService.ts","webpack:///../node_modules/@inversifyjs/common/lib/esm/index.js","webpack:///../node_modules/@inversifyjs/container/lib/esm/index.js","webpack:///../node_modules/@inversifyjs/core/lib/esm/index.js","webpack:///../node_modules/@inversifyjs/prototype-utils/lib/esm/index.js","webpack:///../node_modules/@inversifyjs/reflect-metadata-utils/lib/esm/index.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/AbortController.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/AccessTokenHttpClient.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/DefaultHttpClient.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/DefaultReconnectPolicy.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/Errors.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/FetchHttpClient.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/HandshakeProtocol.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/HeaderNames.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/HttpClient.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/HttpConnection.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/HubConnection.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/HubConnectionBuilder.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/IHubProtocol.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/ILogger.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/ITransport.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/JsonHubProtocol.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/Loggers.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/LongPollingTransport.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/MessageBuffer.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/ServerSentEventsTransport.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/Subject.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/TextMessageFormat.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/Utils.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/WebSocketTransport.js","webpack:///../node_modules/@microsoft/signalr/dist/esm/XhrHttpClient.js","webpack:///../node_modules/inversify/lib/esm/index.js","webpack:///../node_modules/reflect-metadata/Reflect.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/global","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./main.ts"],"sourcesContent":["import { injectable, inject } from \"inversify\";\r\nimport { IReactiveFormGroup } from \"../Interfaces/IReactiveFormGroup\";\r\nimport { ContainerTypes } from \"../Types/ContainerTypes\"; // Update the path as needed\r\nimport { IParsedFormDefinition } from \"../Interfaces/IParsedFormDefinition\"; // Add this import\r\nimport { IFormParserService } from \"../Interfaces/IFormParserService\";\r\nimport { IFormGroupFactory } from \"../Interfaces/IFormGroupFactory\";\r\nimport { IFormControlFactory } from \"../Interfaces/IFormControlFactory\";\r\nimport { IReactiveFormBuilder } from \"../Interfaces/IReactiveFormBuilder\";\r\n@injectable()\r\nexport class ReactiveFormBuilder implements IReactiveFormBuilder {\r\n  constructor(\r\n    @inject(ContainerTypes.FormParserService) private parser: IFormParserService,\r\n    @inject(ContainerTypes.FormGroupFactory) private formGroupFactory: IFormGroupFactory,\r\n    @inject(ContainerTypes.FormControlFactory) private controlFactory: IFormControlFactory\r\n  ) {}\r\n\r\n  buildAll(): IReactiveFormGroup[] {\r\n    const parsedForms = this.parser.parseAll();\r\n    return parsedForms.map(def => this.buildFormInternal(def)).filter(Boolean) as IReactiveFormGroup[];\r\n  }\r\n\r\n  buildForm(form: HTMLFormElement): IReactiveFormGroup | null {\r\n    const def = this.parser.parseForm(form);\r\n    return def ? this.buildFormInternal(def) : null;\r\n  }\r\n\r\n  private buildFormInternal(def: IParsedFormDefinition): IReactiveFormGroup {\r\n    const group = this.formGroupFactory.create(def);\r\n\r\n    for (const controlDef of def.controls) {\r\n      const control = this.controlFactory.createControl(controlDef.key, controlDef.rules);\r\n      group.registerControl(controlDef.key, control);\r\n    }\r\n\r\n    return group;\r\n  }\r\n}","import { Container } from \"inversify\";\r\nimport { ContainerTypes } from \"../Types/ContainerTypes\";\r\nimport { IFormParserService } from \"../Interfaces/IFormParserService\";\r\nimport { FormParserService } from \"../../Services/FormParserService\";\r\nimport { FormStateProvider } from \"../Providers/FormStateProvider\";\r\nimport { IFieldStateProvider } from \"../Interfaces/IFieldStateProvider\";\r\nimport { IFormStateProvider } from \"../Interfaces/IFormStateProvider\";\r\nimport { IReactiveFormControl } from \"../Interfaces/IReactiveFormControl\";\r\nimport { IReactiveFormGroup } from \"../Interfaces/IReactiveFormGroup\";\r\nimport { ReactiveFormGroup } from \"../FormGroup/ReactiveFormGroup\";\r\nimport { ReactiveFormControl } from \"../FormControl/ReactiveFormControl\";\r\nimport { SignalRConnectionProvider } from \"../Providers/SignalRConnectionProvider\";\r\nimport { ISignalRConnectionProvider } from \"../Interfaces/ISignalRConnectionProvider\";\r\n\r\n\r\nimport { HttpValidationHandler } from \"../Handlers/HttpValidationHandler\";\r\n\r\nimport { SignalRValidationHandler } from \"../Handlers/SignalRValidationHandler\";\r\nimport { IAsyncValidationHandler } from \"../Interfaces/IAsyncValidationHandler\";\r\nimport { AsyncValidatorFactory } from \"../Factory/AsyncValidationFactory\";\r\nimport { IFormControlFactory } from \"../Interfaces/IFormControlFactory\";\r\nimport { FormControlFactory } from \"../Factory/FormControlFactory\";\r\nimport { IValidatorFactory } from \"../Interfaces/IValidatorFactory\";\r\nimport { ValidatorFactory } from \"../Factory/ValidatorFactory\";\r\nimport { IReactiveFormControlFactory } from \"../Interfaces/IReactiveFormControlFactory\";\r\nimport { ReactiveFormControlFactory } from \"../Factory/ReactiveFormControlFactory\";\r\nimport { IFormGroupFactory } from \"../Interfaces/IFormGroupFactory\";\r\nimport { FormGroupFactory } from \"../Factory/FormGroupFactory\";\r\nimport { IReactiveFormBuilder } from \"../Interfaces/IReactiveFormBuilder\";\r\nimport { ReactiveFormBuilder } from \"../Builders/ReactiveFormBuilder\";\r\nimport { IReactiveFormService } from \"../Interfaces/IReactiveFormService\";\r\nimport { ReactiveFormService } from \"../../Services/ReactiveFormService\";\r\nimport { IReactiveValidatorService } from \"../Interfaces/IReactiveValidatorService\";\r\nimport { ReactiveValidatorService } from \"../../Services/ReactiveValidatorService\";\r\n\r\n\r\n// Init container\r\nconst container = new Container();\r\n\r\n// Parser\r\ncontainer.bind<IFormParserService>(ContainerTypes.FormParserService).to(FormParserService);\r\n\r\n// State Provider (dual-interface binding)\r\ncontainer.bind<FormStateProvider>(FormStateProvider).toSelf().inSingletonScope();\r\ncontainer.bind<IFieldStateProvider>(ContainerTypes.FieldStateProvider).toService(FormStateProvider);\r\ncontainer.bind<IFormStateProvider>(ContainerTypes.FormStateProvider).toService(FormStateProvider);\r\n// Builders\r\ncontainer.bind<IReactiveFormBuilder>(ContainerTypes.ReactiveFormBuilder).to(ReactiveFormBuilder).inSingletonScope();\r\n// Reactive controls\r\ncontainer.bind<IReactiveFormControl>(ContainerTypes.ReactiveFormControl).to(ReactiveFormControl);\r\ncontainer.bind<IReactiveFormGroup>(ContainerTypes.ReactiveFormGroup).to(ReactiveFormGroup);\r\n\r\n// Validator Handlers\r\ncontainer.bind<ISignalRConnectionProvider>(ContainerTypes.SignalRConnectionProvider).to(SignalRConnectionProvider).inSingletonScope();\r\ncontainer.bind<IAsyncValidationHandler>(ContainerTypes.SignalRValidationHandler).to(SignalRValidationHandler);\r\ncontainer.bind<IAsyncValidationHandler>(ContainerTypes.HttpValidationHandler).to(HttpValidationHandler);\r\n\r\n// Factories\r\ncontainer.bind<AsyncValidatorFactory>(ContainerTypes.AsyncValidatorFactory).to(AsyncValidatorFactory).inSingletonScope();\r\ncontainer.bind<AsyncValidatorFactory>(ContainerTypes.AsyncValidatorFactory).to(AsyncValidatorFactory).inSingletonScope();\r\n\r\ncontainer.bind<IFormControlFactory>(ContainerTypes.FormControlFactory).to(FormControlFactory).inSingletonScope();\r\ncontainer.bind<IReactiveFormControlFactory>(ContainerTypes.ReactiveFormControlFactory).to(ReactiveFormControlFactory).inSingletonScope();\r\ncontainer.bind<IValidatorFactory>(ContainerTypes.ValidatorFactory).to(ValidatorFactory).inSingletonScope();\r\ncontainer.bind<IFormGroupFactory>(ContainerTypes.FormGroupFactory).to(FormGroupFactory).inSingletonScope();\r\n\r\n// Services\r\ncontainer.bind<IReactiveFormService>(ContainerTypes.ReactiveFormService).to(ReactiveFormService).inSingletonScope();\r\ncontainer.bind<IReactiveValidatorService>(ContainerTypes.ReactiveValidatorService).to(ReactiveValidatorService).inSingletonScope();\r\n\r\n// Export the configured container\r\n\r\nexport { container };","import { inject, injectable } from \"inversify\";\r\nimport { IAsyncValidatorFactory } from \"../Interfaces/IAsyncValidationFactory\";\r\nimport { ContainerTypes } from \"../Types/ContainerTypes\";\r\n\r\nimport { IValidationRuleConfig } from \"../Interfaces/IValidationRuleConfig\";\r\nimport { IAsyncValidator } from \"../Interfaces/IAsyncValidator\";\r\nimport { IAsyncValidationHandler } from \"../Interfaces/IAsyncValidationHandler\";\r\n\r\n\r\n\r\n\r\n@injectable()\r\n@injectable()\r\nexport class AsyncValidatorFactory implements IAsyncValidatorFactory {\r\n  constructor(\r\n    @inject(ContainerTypes.SignalRValidationHandler)\r\n    private signalRHandler: IAsyncValidationHandler,\r\n\r\n    @inject(ContainerTypes.HttpValidationHandler)\r\n    private httpHandler: IAsyncValidationHandler\r\n  ) {}\r\n\r\n  createAsyncValidators(rules: IValidationRuleConfig[]): IAsyncValidator[] {\r\n    return rules\r\n      .filter(rule => rule.type === \"signalr\" || rule.type === \"http\")\r\n      .map(rule => {\r\n        const handler = this.resolveHandler(rule.type);\r\n        return {\r\n          rule,\r\n          validate: (value: string, context: Record<string, any>) =>\r\n            handler.validateAsync(rule, value, context),\r\n        };\r\n      });\r\n  }\r\n\r\n  private resolveHandler(type: string): IAsyncValidationHandler {\r\n    switch (type) {\r\n      case \"signalr\":\r\n        return this.signalRHandler;\r\n      case \"http\":\r\n        return this.httpHandler;\r\n      default:\r\n        throw new Error(`[AsyncValidatorFactory] Unknown async validator type: ${type}`);\r\n    }\r\n  }\r\n}","import { inject, injectable } from \"inversify\";\r\nimport { IFormControlFactory } from \"../Interfaces/IFormControlFactory\";\r\nimport { IReactiveFormControl } from \"../Interfaces/IReactiveFormControl\";\r\nimport { IValidator } from \"../Interfaces/IValidator\";\r\nimport { IAsyncValidator } from \"../Interfaces/IAsyncValidator\";\r\nimport { ContainerTypes } from \"../Types/ContainerTypes\";\r\nimport { IFieldStateProvider } from \"../Interfaces/IFieldStateProvider\";\r\nimport { ReactiveFormControl } from \"../FormControl/ReactiveFormControl\";\r\nimport { IValidatorFactory } from \"../Interfaces/IValidatorFactory\";\r\nimport { IAsyncValidatorFactory } from \"../Interfaces/IAsyncValidationFactory\";\r\nimport { IValidationRuleConfig } from \"../Interfaces/IValidationRuleConfig\";\r\nimport { IReactiveFormControlFactory } from \"../Interfaces/IReactiveFormControlFactory\";\r\n\r\n@injectable()\r\nexport class FormControlFactory implements IFormControlFactory {\r\n  constructor(\r\n    @inject(ContainerTypes.ValidatorFactory)\r\n    private validatorFactory: IValidatorFactory,\r\n\r\n    @inject(ContainerTypes.AsyncValidatorFactory)\r\n    private asyncValidatorFactory: IAsyncValidatorFactory,\r\n\r\n    @inject(ContainerTypes.ReactiveFormControlFactory)\r\n    private controlFactory: IReactiveFormControlFactory\r\n  ) {}\r\n\r\n  createControl(\r\n    key: string,\r\n    rules: IValidationRuleConfig[]\r\n  ): IReactiveFormControl {\r\n    const validators: IValidator[] = this.validatorFactory.createValidators(rules);\r\n    const asyncValidators: IAsyncValidator[] = this.asyncValidatorFactory.createAsyncValidators(rules);\r\n    return this.create(key, validators, asyncValidators);\r\n  }\r\n\r\n  create(\r\n    key: string,\r\n    validators: IValidator[],\r\n    asyncValidators: IAsyncValidator[] = []\r\n  ): IReactiveFormControl {\r\n    const control = this.controlFactory.createInstance();\r\n    control.initialize(key, validators, asyncValidators);\r\n    return control;\r\n  }\r\n}\r\n","import { inject, injectable } from \"inversify\";\r\nimport { IFormGroupFactory } from \"../Interfaces/IFormGroupFactory\";\r\nimport { IReactiveFormGroup } from \"../Interfaces/IReactiveFormGroup\";\r\nimport { IFormControlFactory } from \"../Interfaces/IFormControlFactory\";\r\nimport { IParsedFormDefinition } from \"../Interfaces/IParsedFormDefinition\";\r\n\r\nimport { ContainerTypes } from \"../Types/ContainerTypes\";\r\nimport { ReactiveFormGroup } from \"../FormGroup/ReactiveFormGroup\";\r\n\r\n\r\n@injectable()\r\nexport class FormGroupFactory implements IFormGroupFactory {\r\n  constructor(\r\n    @inject(ContainerTypes.FormControlFactory)\r\n    private controlFactory: IFormControlFactory\r\n  ) {}\r\n\r\n  // Optional alias or overload for more semantic naming\r\n  createGroup(parsed: IParsedFormDefinition): IReactiveFormGroup {\r\n    return this.create(parsed);\r\n  }\r\n\r\n  create(formDef: IParsedFormDefinition): IReactiveFormGroup {\r\n    const group = new ReactiveFormGroup();\r\n\r\n    for (const def of formDef.controls) {\r\n      const control = this.controlFactory.createControl(def.key, def.rules);\r\n      group.registerControl(def.key, control);\r\n    }\r\n\r\n    return group;\r\n  }\r\n}","import { inject, injectable } from \"inversify\";\r\nimport { IReactiveFormControlFactory } from \"../Interfaces/IReactiveFormControlFactory\";\r\nimport { IReactiveFormControl } from \"../Interfaces/IReactiveFormControl\";\r\nimport { ReactiveFormControl } from \"../FormControl/ReactiveFormControl\";\r\nimport { ContainerTypes } from \"../Types/ContainerTypes\";\r\nimport { IFieldStateProvider } from \"../Interfaces/IFieldStateProvider\";\r\n\r\n@injectable()\r\nexport class ReactiveFormControlFactory implements IReactiveFormControlFactory {\r\n  constructor(\r\n    @inject(ContainerTypes.FormStateProvider)\r\n    private readonly fieldStateProvider: IFieldStateProvider\r\n  ) {}\r\n\r\n  createInstance(): IReactiveFormControl {\r\n    return new ReactiveFormControl(this.fieldStateProvider);\r\n  }\r\n}","import { injectable } from \"inversify\";\r\nimport { IValidatorFactory } from \"../Interfaces/IValidatorFactory\";\r\nimport { IValidationRuleConfig } from \"../Interfaces/IValidationRuleConfig\";\r\nimport { IValidator } from \"../Interfaces/IValidator\";\r\nimport {\r\n  MatchesValidator,\r\n  MaxLengthValidator,\r\n  MinLengthValidator,\r\n  PatternValidator,\r\n  RequiredValidator,\r\n} from \"../Validators/RequiredValidator\";\r\n\r\n@injectable()\r\nexport class ValidatorFactory implements IValidatorFactory {\r\n  createValidators(rules: IValidationRuleConfig[]): IValidator[] {\r\n    return rules\r\n      .map((rule) => this.createValidator(rule))\r\n      .filter((v): v is IValidator => v !== null);\r\n  }\r\n\r\n  private createValidator(rule: IValidationRuleConfig): IValidator | null {\r\n    switch (rule.type) {\r\n      case \"required\":\r\n        return new RequiredValidator(rule);\r\n      case \"minLength\":\r\n        return new MinLengthValidator(rule);\r\n      case \"maxLength\":\r\n        return new MaxLengthValidator(rule);\r\n      case \"pattern\":\r\n        return new PatternValidator(rule);\r\n      case \"matches\":\r\n        return new MatchesValidator(rule);\r\n      default:\r\n        console.warn(`[ValidatorFactory] Unknown validator type: ${rule.type}`);\r\n        return null;\r\n    }\r\n  }\r\n}\r\n","import { inject, injectable } from \"inversify\";\r\nimport { IAsyncValidator } from \"../Interfaces/IAsyncValidator\";\r\nimport { IFieldState } from \"../Interfaces/IFieldState\";\r\nimport { IReactiveFormGroup } from \"../Interfaces/IReactiveFormGroup\";\r\nimport { IValidator } from \"../Interfaces/IValidator\";\r\nimport { ValidationState } from \"../Types/AppTypes\";\r\nimport { IReactiveFormControl } from \"../Interfaces/IReactiveFormControl\";\r\nimport { SimpleSubject } from \"../Utils/SimpleSubject\";\r\nimport { IFieldStateProvider } from \"../Interfaces/IFieldStateProvider\";\r\nimport { ContainerTypes } from \"../Types/ContainerTypes\";\r\nimport { Debouncer } from \"../Utils/Debounce\";\r\n\r\n@injectable()\r\nexport class ReactiveFormControl implements IReactiveFormControl {\r\n  private key!: string;\r\n  private value = \"\";\r\n  private state: ValidationState = \"idle\";\r\n  private errorMessage: string | null = null;\r\n  private dirty = false;\r\n  private touched = false;\r\n  private validatedOnce = false;\r\n  private validators: IValidator[] = [];\r\n  private asyncValidators: IAsyncValidator[] = [];\r\n  private currentRunId = 0;\r\n  private lastValidatedValue: string | null = null;\r\n  private formGroup?: IReactiveFormGroup;\r\n\r\n  private value$ = new SimpleSubject<string>();\r\n  private error$ = new SimpleSubject<string | null>();\r\n  private state$ = new SimpleSubject<ValidationState>();\r\n\r\n  private debouncer: Debouncer<(val: string) => void>;\r\n\r\n    constructor(\r\n        @inject(ContainerTypes.FieldStateProvider) private stateProvider: IFieldStateProvider\r\n    ) {\r\n        this.debouncer = new Debouncer<(val: string) => void>(this.updateValueDebounced.bind(this), 300);\r\n    }\r\n\r\n  initialize(\r\n    key: string,\r\n    validators: IValidator[],\r\n    asyncValidators: IAsyncValidator[] = []\r\n  ): void {\r\n    this.key = key;\r\n    this.validators = validators;\r\n    this.asyncValidators = asyncValidators;\r\n  }\r\n\r\n  setFormGroup(group: IReactiveFormGroup): void {\r\n    this.formGroup = group;\r\n  }\r\n\r\n  onValueChange(cb: (val: string) => void): void {\r\n    this.value$.subscribe(cb);\r\n  }\r\n\r\n  onErrorChange(cb: (msg: string | null) => void): void {\r\n    this.error$.subscribe(cb);\r\n  }\r\n\r\n  onStateChange(cb: (state: ValidationState) => void): void {\r\n    this.state$.subscribe(cb);\r\n  }\r\n\r\n  async setValue(val: string): Promise<void> {\r\n    if (val === this.value) return;\r\n    this.value = val;\r\n    this.dirty = true;\r\n    this.emitValue(val);\r\n    this.emitDirtyTouched();\r\n    if (this.touched) {\r\n      this.debouncer.run(val);\r\n    }\r\n  }\r\n\r\n  updateValueDebounced(val: string): void {\r\n    if (val === this.value) return;\r\n    this.value = val;\r\n    this.dirty = true;\r\n    this.emitValue(val);\r\n    this.emitDirtyTouched();\r\n    if (this.touched) {\r\n      this.debouncer.run(val);\r\n    }\r\n  }\r\n\r\n  async markAsTouched(): Promise<void> {\r\n    if (!this.touched) {\r\n      this.touched = true;\r\n      this.emitDirtyTouched();\r\n      if (this.dirty || !this.validatedOnce) {\r\n        await this.validateInternal(this.value, true);\r\n      }\r\n    }\r\n  }\r\n\r\n  validate(): Promise<boolean> {\r\n    this.touched = true;\r\n    this.validatedOnce = true;\r\n    this.emitDirtyTouched();\r\n    return this.validateInternal(this.value, true);\r\n  }\r\n\r\n  validateNow(): Promise<boolean> {\r\n    return this.validate();\r\n  }\r\n\r\n  setValidationRules(validators: IValidator[], asyncValidators: IAsyncValidator[] = []): void {\r\n    this.validators = validators;\r\n    this.asyncValidators = asyncValidators;\r\n    if (this.touched || this.dirty) {\r\n      this.validate();\r\n    }\r\n  }\r\n\r\n  async setServerValidationState(result: { state: ValidationState; message?: string }): Promise<void> {\r\n    this.validatedOnce = true;\r\n    this.touched = true;\r\n    this.setState(result.state);\r\n    this.setError(result.state === \"valid\" ? null : result.message || \"Invalid input\");\r\n  }\r\n\r\n  // --- Observables + Emitters ---\r\n  private emitValue(val: string): void {\r\n    this.value$.next(val);\r\n    this.emitState();\r\n  }\r\n\r\n  private setError(msg: string | null): void {\r\n    this.errorMessage = msg;\r\n    this.error$.next(msg);\r\n    this.emitState();\r\n  }\r\n\r\n  private setState(state: ValidationState): void {\r\n    this.state = state;\r\n    this.state$.next(state);\r\n    this.emitState();\r\n  }\r\n\r\n  private emitDirtyTouched(): void {\r\n    this.emitState();\r\n  }\r\n\r\n  private emitState(): void {\r\n    const state: IFieldState = {\r\n      key: this.key,\r\n      value: this.value,\r\n      state: this.state,\r\n      error: this.errorMessage,\r\n      dirty: this.dirty,\r\n      touched: this.touched,\r\n    };\r\n    this.stateProvider.updateFieldState(state);\r\n  }\r\n\r\n  private async validateInternal(val: string, isExplicit = false): Promise<boolean> {\r\n    const runId = ++this.currentRunId;\r\n    const context = this.formGroup?.getValue() ?? { [this.key]: val };\r\n\r\n    // Required / Early exit\r\n    if (val.trim() === \"\") {\r\n      this.setState(\"invalid\");\r\n      this.setError(\"Field is required.\");\r\n      return false;\r\n    }\r\n\r\n    for (const validator of this.validators) {\r\n      const rawResult = await Promise.resolve(validator.validate(val, context));\r\n      const result = typeof rawResult === \"boolean\"\r\n        ? { isValid: rawResult, message: rawResult ? undefined : \"Invalid input\" }\r\n        : rawResult;\r\n      if (!result.isValid) {\r\n        this.setState(\"invalid\");\r\n        this.setError(result.message ?? \"Invalid input\");\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (this.asyncValidators.length > 0 && (isExplicit || this.lastValidatedValue !== val)) {\r\n      this.setState(\"validating\");\r\n      this.setError(null);\r\n\r\n      for (const validator of this.asyncValidators) {\r\n        const result = await validator.validate(val, context);\r\n        if (this.currentRunId !== runId) return false;\r\n        if (!result.isValid) {\r\n          this.setState(\"invalid\");\r\n          this.setError(result.message ?? \"Invalid input\");\r\n          return false;\r\n        }\r\n      }\r\n\r\n      this.lastValidatedValue = val;\r\n    }\r\n\r\n    this.setState(\"valid\");\r\n    this.setError(null);\r\n    return true;\r\n  }\r\n\r\n  // --- Getters ---\r\n  isDirty(): boolean {\r\n    return this.dirty;\r\n  }\r\n\r\n  wasTouched(): boolean {\r\n    return this.touched;\r\n  }\r\n\r\n  isValid(): boolean {\r\n    return this.state === \"valid\";\r\n  }\r\n\r\n  get currentValue(): string {\r\n    return this.value;\r\n  }\r\n\r\n  get currentState(): ValidationState {\r\n    return this.state;\r\n  }\r\n\r\n  getError(): string | null {\r\n    return this.errorMessage;\r\n  }\r\n}","import { injectable } from \"inversify\";\r\nimport { IReactiveFormControl } from \"../Interfaces/IReactiveFormControl\";\r\nimport { IReactiveFormGroup } from \"../Interfaces/IReactiveFormGroup\";\r\nimport { ReactiveFormDebugState } from \"../Interfaces/IReactiveFormGroupState\";\r\nimport { SimpleSubject } from \"../Utils/SimpleSubject\";\r\n\r\n@injectable()\r\nexport class ReactiveFormGroup implements IReactiveFormGroup {\r\n  private controls: Map<string, IReactiveFormControl> = new Map();\r\n  private debug$ = new SimpleSubject<ReactiveFormDebugState>();\r\n\r\n  registerControl(key: string, control: IReactiveFormControl): void {\r\n    this.controls.set(key, control);\r\n\r\n    // Auto-wire debug pipe for any control change\r\n    control.onValueChange(() => this.emitDebug());\r\n    control.onStateChange(() => this.emitDebug());\r\n    control.onErrorChange(() => this.emitDebug());\r\n  }\r\n\r\n  getControl(key: string): IReactiveFormControl | undefined {\r\n    return this.controls.get(key);\r\n  }\r\n\r\n  getValue(): Record<string, string> {\r\n    const result: Record<string, string> = {};\r\n    for (const [key, control] of this.controls.entries()) {\r\n      result[key] = control.currentValue;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  async validateAll(): Promise<boolean> {\r\n    const results = await Promise.all(\r\n      Array.from(this.controls.values()).map(c => c.validate())\r\n    );\r\n    return results.every(result => result === true);\r\n  }\r\n\r\n  isValid(): boolean {\r\n    return Array.from(this.controls.values()).every(c => c.isValid());\r\n  }\r\n\r\n  isDirty(): boolean {\r\n    return Array.from(this.controls.values()).some(c => c.isDirty());\r\n  }\r\n\r\n  wasTouched(): boolean {\r\n    return Array.from(this.controls.values()).some(c => c.wasTouched());\r\n  }\r\n\r\n  onDebugUpdate(callback: (debugState: ReactiveFormDebugState) => void): void {\r\n    this.debug$.subscribe(callback);\r\n  }\r\n\r\n  private emitDebug(): void {\r\n    const debug: ReactiveFormDebugState = {\r\n      timestamp: Date.now(),\r\n      isValid: this.isValid(),\r\n      isDirty: this.isDirty(),\r\n      wasTouched: this.wasTouched(),\r\n      values: {},\r\n      states: {},\r\n      errors: {},\r\n      raw: {}\r\n    };\r\n\r\n    for (const [key, control] of this.controls.entries()) {\r\n      debug.values[key] = control.currentValue;\r\n      debug.states[key] = control.currentState;\r\n      debug.errors[key] = control.getError();\r\n      debug.raw[key] = control;\r\n    }\r\n\r\n    this.debug$.next(debug);\r\n  }\r\n}\r\n","import { injectable } from \"inversify\";\r\n\r\nimport { IValidationRuleConfig } from \"../Interfaces/IValidationRuleConfig\";\r\nimport { IAsyncValidationHandler } from \"../Interfaces/IAsyncValidationHandler\";\r\n\r\n@injectable()\r\nexport class HttpValidationHandler implements IAsyncValidationHandler {\r\n  async validateAsync(\r\n    rule: IValidationRuleConfig,\r\n    value: string,\r\n    context: Record<string, any>\r\n  ): Promise<{ isValid: boolean; message?: string }> {\r\n    try {\r\n      const endpoint = rule.methodName; // Expect full URL\r\n      const payload = { value, context, args: rule.args || [] };\r\n\r\n      const res = await fetch(endpoint!, {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        body: JSON.stringify(payload)\r\n      });\r\n\r\n      if (!res.ok) throw new Error(\"Request failed\");\r\n\r\n      return await res.json();\r\n    } catch (err) {\r\n      console.error(\"[HttpValidationHandler] Failed:\", err);\r\n      return { isValid: false, message: \"Validation service unavailable.\" };\r\n    }\r\n  }\r\n}","import { inject, injectable } from \"inversify\";\r\n\r\nimport { ISignalRConnectionProvider } from \"../Interfaces/ISignalRConnectionProvider\";\r\nimport { ContainerTypes } from \"../Types/ContainerTypes\";\r\n\r\nimport { IAsyncValidationHandler } from \"../Interfaces/IAsyncValidationHandler\";\r\nimport { IValidationRuleConfig } from \"../Interfaces/IValidationRuleConfig\";\r\n@injectable()\r\nexport class SignalRValidationHandler implements IAsyncValidationHandler {\r\n  constructor(\r\n    @inject(ContainerTypes.SignalRConnectionProvider)\r\n    private connectionProvider: ISignalRConnectionProvider\r\n  ) {}\r\n\r\n  async validateAsync(\r\n    rule: IValidationRuleConfig,\r\n    value: string,\r\n    context: Record<string, any>\r\n  ): Promise<{ isValid: boolean; message?: string }> {\r\n    const connection = await this.connectionProvider.getConnection();\r\n    const result = await connection.invoke<{ isValid: boolean; message?: string }>(\r\n      rule.methodName!,\r\n      value,\r\n      context,\r\n      rule.args ?? []\r\n    );\r\n\r\n    return result;\r\n  }\r\n}","import { IFieldState } from \"../Interfaces/IFieldState\";\r\nimport { IFieldStateProvider } from \"../Interfaces/IFieldStateProvider\";\r\nimport { IFormState } from \"../Interfaces/IFormState\";\r\nimport { IFormStateProvider } from \"../Interfaces/IFormStateProvider\";\r\n\r\nexport class FormStateProvider implements IFieldStateProvider, IFormStateProvider {\r\n  private fieldStates = new Map<string, IFieldState>();\r\n  private fieldSubscribers = new Map<string, ((state: IFieldState) => void)[]>();\r\n  private formSubscribers: ((state: IFormState) => void)[] = [];\r\n\r\n  getFieldState(key: string): IFieldState | null {\r\n    return this.fieldStates.get(key) ?? null;\r\n  }\r\n\r\n  updateFieldState(state: IFieldState): void {\r\n    this.fieldStates.set(state.key, state);\r\n\r\n    // Notify field listeners\r\n    this.fieldSubscribers.get(state.key)?.forEach(cb => cb(state));\r\n\r\n    // Notify form-level listeners\r\n    const formState = this.getFormState();\r\n    this.formSubscribers.forEach(cb => cb(formState));\r\n  }\r\n\r\n  subscribeField(key: string, callback: (state: IFieldState) => void): void {\r\n    if (!this.fieldSubscribers.has(key)) {\r\n      this.fieldSubscribers.set(key, []);\r\n    }\r\n    this.fieldSubscribers.get(key)!.push(callback);\r\n  }\r\n\r\n  subscribeForm(callback: (formState: IFormState) => void): void {\r\n    this.formSubscribers.push(callback);\r\n  }\r\n\r\n  getFormState(): IFormState {\r\n    const fields: Record<string, IFieldState> = {};\r\n    let isValid = true;\r\n\r\n    for (const [key, value] of this.fieldStates.entries()) {\r\n      fields[key] = value;\r\n      if (value.state === \"invalid\") isValid = false;\r\n    }\r\n\r\n    return { fields, isValid };\r\n  }\r\n}","import { HubConnection, HubConnectionBuilder } from \"@microsoft/signalr\";\r\nimport { injectable } from \"inversify\";\r\nimport { ISignalRConnectionProvider } from \"../Interfaces/ISignalRConnectionProvider\";\r\n\r\n\r\n\r\n@injectable()\r\nexport class SignalRConnectionProvider implements ISignalRConnectionProvider {\r\n  private connection: HubConnection | null = null;\r\n  private connecting: Promise<HubConnection> | null = null;\r\n  private connectionId: string | null = null;\r\n  private connectionIdPromise: Promise<string> | null = null;\r\n\r\n  async getConnection(): Promise<HubConnection> {\r\n    if (this.connection) return this.connection;\r\n\r\n    if (!this.connecting) {\r\n      this.connecting = new Promise<HubConnection>(async (resolve, reject) => {\r\n        try {\r\n          const conn = new HubConnectionBuilder()\r\n            .withUrl(\"/hubs/validation\")\r\n            .withAutomaticReconnect()\r\n            .build();\r\n\r\n          await conn.start();\r\n          console.log(\"[SignalR] Connected to validation hub.\");\r\n\r\n          this.connection = conn;\r\n\r\n          // Optionally pre-fetch connectionId\r\n          this.getConnectionId().catch((err) =>\r\n            console.warn(\"[SignalR] Could not get connectionId:\", err)\r\n          );\r\n\r\n          resolve(conn);\r\n        } catch (err) {\r\n          console.error(\"[SignalR] Connection failed:\", err);\r\n          reject(err);\r\n        } finally {\r\n          this.connecting = null;\r\n        }\r\n      });\r\n    }\r\n\r\n    return this.connecting;\r\n  }\r\n\r\n  /**\r\n   * Gets the current connectionId (resolved after connection is started).\r\n   * Assumes the backend exposes a hub method named 'GetConnectionId'.\r\n   */\r\n  async getConnectionId(): Promise<string> {\r\n    if (this.connectionId) return this.connectionId;\r\n\r\n    if (!this.connectionIdPromise) {\r\n      this.connectionIdPromise = new Promise<string>(async (resolve, reject) => {\r\n        try {\r\n          const conn = await this.getConnection();\r\n          // Assumes your hub has a 'GetConnectionId' method\r\n          const id = await conn.invoke<string>(\"GetConnectionId\");\r\n          this.connectionId = id;\r\n          resolve(id);\r\n        } catch (err) {\r\n          reject(err);\r\n        }\r\n      });\r\n    }\r\n    return this.connectionIdPromise;\r\n  }\r\n}\r\n\r\n","import { FormControlFactory } from \"../Factory/FormControlFactory\";\r\nimport { ValidatorFactory } from \"../Factory/ValidatorFactory\";\r\n\r\nexport const ContainerTypes = {\r\n  FormParserService: Symbol.for(\"FormParserService\"),\r\n  FieldStateProvider: Symbol.for(\"FieldStateProvider\"),\r\n  FormStateProvider: Symbol.for(\"FormStateProvider\"),\r\n  ReactiveFormControl: Symbol.for(\"ReactiveFormControl\"),\r\n  ReactiveFormGroup: Symbol.for(\"ReactiveFormGroup\"),\r\n  SignalRConnectionProvider: Symbol.for(\"SignalRConnectionProvider\"),\r\n  SignalRValidationHandler: Symbol.for(\"SignalRValidatorHandler\"),\r\n  HttpValidationHandler: Symbol.for(\"HttpValidatorHandler\"),\r\n  AsyncValidatorFactory: Symbol.for(\"AsyncValidatorFactory\"),\r\n  ValidatorFactory: Symbol.for(\"ValidatorFactory\"),\r\n  FormControlFactory: Symbol.for(\"FormControlFactory\"),\r\n  ReactiveFormControlFactory: Symbol.for(\"ReactiveFormControlFactory\"),\r\n  FormGroupFactory: Symbol.for(\"FormGroupFactory\"),\r\n  ReactiveFormBuilder: Symbol.for(\"ReactiveFormBuilder\"),\r\n  ReactiveFormService: Symbol.for(\"ReactiveFormService\"),\r\n  ReactiveValidatorService: Symbol.for(\"ReactiveValidatorService\")\r\n};\r\n","// utils/debounce.ts\r\n\r\nexport type DebouncedFunction<T extends (...args: any[]) => void> = {\r\n  (...args: Parameters<T>): void;\r\n  cancel: () => void;\r\n};\r\n\r\nexport class Debouncer<T extends (...args: any[]) => void> {\r\n  private debouncedFn: DebouncedFunction<T>;\r\n\r\n  constructor(private fn: T, private delay = 300) {\r\n    this.debouncedFn = this.createDebouncedFn();\r\n  }\r\n\r\n  private createDebouncedFn(): DebouncedFunction<T> {\r\n    let timer: ReturnType<typeof setTimeout> | null = null;\r\n\r\n    const debounced = ((...args: Parameters<T>) => {\r\n      if (timer) clearTimeout(timer);\r\n      timer = setTimeout(() => this.fn(...args), this.delay);\r\n    }) as DebouncedFunction<T>;\r\n\r\n    debounced.cancel = () => {\r\n      if (timer) {\r\n        clearTimeout(timer);\r\n        timer = null;\r\n      }\r\n    };\r\n\r\n    return debounced;\r\n  }\r\n\r\n  run(...args: Parameters<T>) {\r\n    this.debouncedFn(...args);\r\n  }\r\n\r\n  cancel() {\r\n    this.debouncedFn.cancel();\r\n  }\r\n}","export class SimpleSubject<T> {\r\n  private listeners: Set<(value: T) => void> = new Set();\r\n\r\n  subscribe(listener: (value: T) => void): void {\r\n    this.listeners.add(listener);\r\n  }\r\n\r\n  unsubscribe(listener: (value: T) => void): void {\r\n    this.listeners.delete(listener);\r\n  }\r\n\r\n  next(value: T): void {\r\n    this.emit(value);\r\n  }\r\n\r\n  private emit(value: T): void {\r\n    for (const listener of this.listeners) {\r\n      try {\r\n        listener(value);\r\n      } catch (err) {\r\n        console.error(\"[SimpleSubject] Error in subscriber:\", err);\r\n      }\r\n    }\r\n  }\r\n\r\n  clear(): void {\r\n    this.listeners.clear();\r\n  }\r\n\r\n  getSubscriberCount(): number {\r\n    return this.listeners.size;\r\n  }\r\n}\r\n","import { IValidationRuleConfig } from \"../Interfaces/IValidationRuleConfig\";\r\nimport { IValidator } from \"../Interfaces/IValidator\";\r\n\r\nexport class RequiredValidator implements IValidator {\r\n  constructor(private rule: IValidationRuleConfig) {}\r\n\r\n  validate(value: string): boolean | { isValid: boolean; message?: string } {\r\n    const isValid = value.trim().length > 0;\r\n    return isValid || { isValid: false, message: this.rule.message || \"This field is required.\" };\r\n  }\r\n}\r\n\r\nexport class MinLengthValidator implements IValidator {\r\n  constructor(private rule: IValidationRuleConfig) {}\r\n\r\n  validate(value: string): boolean | { isValid: boolean; message?: string } {\r\n    const min = Number(this.rule.value || 0);\r\n    const isValid = value.length >= min;\r\n    return isValid || {\r\n      isValid: false,\r\n      message: this.rule.message || `Minimum length is ${min}.`\r\n    };\r\n  }\r\n}\r\n\r\nexport class MaxLengthValidator implements IValidator {\r\n  constructor(private rule: IValidationRuleConfig) {}\r\n\r\n  validate(value: string): boolean | { isValid: boolean; message?: string } {\r\n    const max = Number(this.rule.value || Infinity);\r\n    const isValid = value.length <= max;\r\n    return isValid || {\r\n      isValid: false,\r\n      message: this.rule.message || `Maximum length is ${max}.`\r\n    };\r\n  }\r\n}\r\n\r\nexport class PatternValidator implements IValidator {\r\n  constructor(private rule: IValidationRuleConfig) {}\r\n\r\n  validate(value: string): boolean | { isValid: boolean; message?: string } {\r\n    const patternValue = typeof this.rule.value === \"string\" ? this.rule.value : String(this.rule.value || \".*\");\r\n    const pattern = new RegExp(patternValue);\r\n    const isValid = pattern.test(value);\r\n    return isValid || {\r\n      isValid: false,\r\n      message: this.rule.message || `Value does not match the required pattern.`\r\n    };\r\n  }\r\n}\r\n\r\n\r\nexport class MatchesValidator implements IValidator {\r\n  constructor(private rule: IValidationRuleConfig) {}\r\n\r\n  validate(value: string, context: Record<string, any>): boolean | { isValid: boolean; message?: string } {\r\n    const matchKey = String(this.rule.value || \"\");\r\n    const matchValue = context[matchKey];\r\n    const isValid = value === matchValue;\r\n    return isValid || {\r\n      isValid: false,\r\n      message: this.rule.message || `Value does not match ${matchKey}.`\r\n    };\r\n  }\r\n}\r\n\r\n\r\n\r\n","import { IFormParserService } from \"../Core/Interfaces/IFormParserService\";\r\nimport { IParsedControlDefinition } from \"../Core/Interfaces/IParsedControlDefinition\";\r\nimport { IParsedFormDefinition } from \"../Core/Interfaces/IParsedFormDefinition\";\r\nimport { IValidationRuleConfig } from \"../Core/Interfaces/IValidationRuleConfig\";\r\n\r\nexport class FormParserService implements IFormParserService {\r\n  /**\r\n   * Parses all forms on the page marked with `[data-reactive-form]`\r\n   */\r\n  parseAll(): IParsedFormDefinition[] {\r\n    const forms = Array.from(document.querySelectorAll<HTMLFormElement>(\"form[data-reactive-form]\"));\r\n    return forms\r\n      .map(form => this.parseForm(form))\r\n      .filter((x): x is IParsedFormDefinition => x !== null);\r\n  }\r\n\r\n  /**\r\n   * Parses a single form element.\r\n   */\r\n  parseForm(form: HTMLFormElement): IParsedFormDefinition | null {\r\n    const raw = form.getAttribute(\"data-validate\");\r\n    if (!raw) return null;\r\n\r\n    let parsed: Record<string, any>;\r\n    try {\r\n      parsed = JSON.parse(raw);\r\n    } catch (err) {\r\n      console.warn(\"[FormParserService] Malformed validation JSON on form:\", form, err);\r\n      return null;\r\n    }\r\n\r\n    const controls: IParsedControlDefinition[] = [];\r\n\r\n    for (const [key, rulesRaw] of Object.entries(parsed)) {\r\n      const input = form.querySelector<HTMLInputElement>(`[name='${key}'], [id='${key}']`);\r\n      if (!input) {\r\n        console.warn(`[FormParserService] No matching input found for key: '${key}'`);\r\n        continue;\r\n      }\r\n\r\n      try {\r\n        const ruleList: IValidationRuleConfig[] = this.parseRuleList(rulesRaw);\r\n        controls.push({ input, key, rules: ruleList });\r\n      } catch (err) {\r\n        console.warn(`[FormParserService] Failed to parse rules for '${key}':`, err);\r\n      }\r\n    }\r\n\r\n    return { form, controls };\r\n  }\r\n\r\n  private parseRuleList(rules: Record<string, any>): IValidationRuleConfig[] {\r\n    const out: IValidationRuleConfig[] = [];\r\n\r\n    for (const [type, val] of Object.entries(rules)) {\r\n      if (typeof type !== \"string\") continue;\r\n\r\n      const config: IValidationRuleConfig = {\r\n        type,\r\n        value: val,\r\n      };\r\n\r\n      if (typeof val === \"object\" && val !== null && !Array.isArray(val)) {\r\n        config.message = val.message;\r\n        config.value = val.value ?? val;\r\n        config.methodName = val.methodName;\r\n        config.args = val.args;\r\n        config.pattern = val.pattern;\r\n        config.matches = val.matches;\r\n        config.validate = val.validate;\r\n      }\r\n\r\n      out.push(config);\r\n    }\r\n\r\n    return out;\r\n  }\r\n}","import { inject, injectable } from \"inversify\";\r\nimport { IReactiveFormService } from \"../Core/Interfaces/IReactiveFormService\";\r\nimport { IReactiveFormGroup } from \"../Core/Interfaces/IReactiveFormGroup\";\r\nimport { ContainerTypes } from \"../Core/Types/ContainerTypes\";\r\nimport { IFormParserService } from \"../Core/Interfaces/IFormParserService\";\r\nimport { IFormGroupFactory } from \"../Core/Interfaces/IFormGroupFactory\";\r\nimport { IParsedFormDefinition } from \"../Core/Interfaces/IParsedFormDefinition\";\r\nimport { ReactiveFormDebugState } from \"../Core/Interfaces/IReactiveFormGroupState\";\r\n\r\n@injectable()\r\nexport class ReactiveFormService implements IReactiveFormService {\r\n  private formMap: Map<HTMLFormElement, IReactiveFormGroup> = new Map();\r\n\r\n  constructor(\r\n    @inject(ContainerTypes.FormParserService)\r\n    private parser: IFormParserService,\r\n\r\n    @inject(ContainerTypes.FormGroupFactory)\r\n    private groupFactory: IFormGroupFactory\r\n  ) {}\r\n\r\n  bootstrapAll(): void {\r\n    const forms = this.parser.parseAll();\r\n    forms.forEach((formDef) => this.bootstrapFormDefinition(formDef));\r\n  }\r\n\r\n  bootstrapForm(form: HTMLFormElement): void {\r\n    const def = this.parser.parseForm(form);\r\n    if (def) {\r\n      this.bootstrapFormDefinition(def);\r\n    } else {\r\n      console.warn(\"[ReactiveFormService] Could not parse form:\", form);\r\n    }\r\n  }\r\n\r\n  private bootstrapFormDefinition(def: IParsedFormDefinition): void {\r\n    const group = this.groupFactory.create(def);\r\n    this.formMap.set(def.form, group);\r\n  }\r\n\r\n  getFormGroup(form: HTMLFormElement): IReactiveFormGroup | null {\r\n    return this.formMap.get(form) ?? null;\r\n  }\r\n\r\n  onDebugUpdate(form: HTMLFormElement, cb: (state: ReactiveFormDebugState) => void): void {\r\n    const group = this.getFormGroup(form);\r\n    if (!group) {\r\n      console.warn(\"[ReactiveFormService] Form not registered:\", form);\r\n      return;\r\n    }\r\n    group.onDebugUpdate(cb);\r\n  }\r\n}","import { inject, injectable } from \"inversify\";\r\nimport { IReactiveValidatorService } from \"../Core/Interfaces/IReactiveValidatorService\";\r\nimport { IFormControlFactory } from \"../Core/Interfaces/IFormControlFactory\";\r\nimport { IFormGroupFactory } from \"../Core/Interfaces/IFormGroupFactory\";\r\nimport { IFormParserService } from \"../Core/Interfaces/IFormParserService\";\r\nimport { IReactiveFormControl } from \"../Core/Interfaces/IReactiveFormControl\";\r\nimport { IReactiveFormGroup } from \"../Core/Interfaces/IReactiveFormGroup\";\r\nimport { IValidationRuleConfig } from \"../Core/Interfaces/IValidationRuleConfig\";\r\nimport { ContainerTypes } from \"../Core/Types/ContainerTypes\";\r\n\r\n@injectable()\r\nexport class ReactiveValidatorService implements IReactiveValidatorService {\r\n  private formRegistry: Map<HTMLFormElement, IReactiveFormGroup> = new Map();\r\n\r\n  constructor(\r\n    @inject(ContainerTypes.FormParserService)\r\n    private parser: IFormParserService,\r\n\r\n    @inject(ContainerTypes.FormControlFactory)\r\n    private controlFactory: IFormControlFactory,\r\n\r\n    @inject(ContainerTypes.FormGroupFactory)\r\n    private groupFactory: IFormGroupFactory\r\n  ) {}\r\n\r\n  createControlFromRules(\r\n    key: string,\r\n    rules: IValidationRuleConfig[]\r\n  ): IReactiveFormControl {\r\n    return this.controlFactory.createControl(key, rules);\r\n  }\r\n\r\n  registerForm(form: HTMLFormElement): IReactiveFormGroup {\r\n    const def = this.parser.parseForm(form);\r\n    if (!def) {\r\n      throw new Error(\"Failed to parse form definition.\");\r\n    }\r\n    const group = this.groupFactory.create(def);\r\n    this.formRegistry.set(form, group);\r\n    return group;\r\n  }\r\n\r\n  async validateForm(group: IReactiveFormGroup): Promise<boolean> {\r\n    return await group.validateAll();\r\n  }\r\n}","function e(e){return(\"object\"==typeof e&&null!==e||\"function\"==typeof e)&&\"function\"==typeof e.then}function t(e){switch(typeof e){case\"string\":case\"symbol\":return e.toString();case\"function\":return e.name;default:throw new Error(`Unexpected ${typeof e} service id type`)}}const n=Symbol.for(\"@inversifyjs/common/islazyServiceIdentifier\");class r{[n];#e;constructor(e){this.#e=e,this[n]=!0}static is(e){return\"object\"==typeof e&&null!==e&&!0===e[n]}unwrap(){return this.#e()}}export{r as LazyServiceIdentifier,e as isPromise,t as stringifyServiceIdentifier};\n//# sourceMappingURL=index.js.map\n","import\"reflect-metadata\";import{getOwnReflectMetadata as i,setReflectMetadata as e,updateOwnReflectMetadata as t}from\"@inversifyjs/reflect-metadata-utils\";import{LazyServiceIdentifier as n,isPromise as s,stringifyServiceIdentifier as a}from\"@inversifyjs/common\";import{getClassMetadata as o,bindingTypeValues as r,bindingScopeValues as c,ResolvedValueElementMetadataKind as d,PlanResultCacheService as l,ActivationsService as u,BindingService as h,DeactivationsService as v,resolveServiceDeactivations as g,resolveModuleDeactivations as b,plan as S,resolve as p}from\"@inversifyjs/core\";const f=\"@inversifyjs/container/bindingId\";class m{#i;#e;constructor(n){this.#i=function(){const n=i(Object,f)??0;return n===Number.MAX_SAFE_INTEGER?e(Object,f,Number.MIN_SAFE_INTEGER):t(Object,f,(()=>n),(i=>i+1)),n}(),this.#e=n}get id(){return this.#i}async load(i){await this.#e(i)}}class y{static always=i=>!0}const w=\"@inversifyjs/container/bindingId\";function I(){const n=i(Object,w)??0;return n===Number.MAX_SAFE_INTEGER?e(Object,w,Number.MIN_SAFE_INTEGER):t(Object,w,(()=>n),(i=>i+1)),n}function A(i){return e=>{for(let t=e.getAncestor();void 0!==t;t=t.getAncestor())if(i(t))return!0;return!1}}function P(i){return e=>e.name===i}function R(i){return e=>e.serviceIdentifier===i}function B(i,e){return t=>t.tags.has(i)&&t.tags.get(i)===e}function C(i){return void 0===i.name&&0===i.tags.size}function M(i){const e=A(i);return i=>!e(i)}function N(i){return e=>{const t=e.getAncestor();return void 0===t||!i(t)}}function x(i){return e=>{const t=e.getAncestor();return void 0!==t&&i(t)}}class O{#t;constructor(i){this.#t=i}inRequestScope(){return this.#t.scope=c.Request,new j(this.#t)}inSingletonScope(){return this.#t.scope=c.Singleton,new j(this.#t)}inTransientScope(){return this.#t.scope=c.Transient,new j(this.#t)}}class F{#n;#s;#a;#o;constructor(i,e,t,n){this.#n=i,this.#s=e,this.#a=t,this.#o=n}to(i){const e=o(i),t={cache:{isRight:!1,value:void 0},id:I(),implementationType:i,isSatisfiedBy:y.always,moduleId:this.#s,onActivation:void 0,onDeactivation:void 0,scope:e.scope??this.#a,serviceIdentifier:this.#o,type:r.Instance};return this.#n(t),new E(t)}toSelf(){if(\"function\"!=typeof this.#o)throw new Error('\"toSelf\" function can only be applied when a newable function is used as service identifier');return this.to(this.#o)}toConstantValue(i){const e={cache:{isRight:!1,value:void 0},id:I(),isSatisfiedBy:y.always,moduleId:this.#s,onActivation:void 0,onDeactivation:void 0,scope:c.Singleton,serviceIdentifier:this.#o,type:r.ConstantValue,value:i};return this.#n(e),new j(e)}toDynamicValue(i){const e={cache:{isRight:!1,value:void 0},id:I(),isSatisfiedBy:y.always,moduleId:this.#s,onActivation:void 0,onDeactivation:void 0,scope:this.#a,serviceIdentifier:this.#o,type:r.DynamicValue,value:i};return this.#n(e),new E(e)}toResolvedValue(i,e){const t={cache:{isRight:!1,value:void 0},factory:i,id:I(),isSatisfiedBy:y.always,metadata:this.#r(e),moduleId:this.#s,onActivation:void 0,onDeactivation:void 0,scope:this.#a,serviceIdentifier:this.#o,type:r.ResolvedValue};return this.#n(t),new E(t)}toFactory(i){const e={cache:{isRight:!1,value:void 0},factory:i,id:I(),isSatisfiedBy:y.always,moduleId:this.#s,onActivation:void 0,onDeactivation:void 0,scope:c.Singleton,serviceIdentifier:this.#o,type:r.Factory};return this.#n(e),new j(e)}toProvider(i){const e={cache:{isRight:!1,value:void 0},id:I(),isSatisfiedBy:y.always,moduleId:this.#s,onActivation:void 0,onDeactivation:void 0,provider:i,scope:c.Singleton,serviceIdentifier:this.#o,type:r.Provider};return this.#n(e),new j(e)}toService(i){const e={id:I(),isSatisfiedBy:y.always,moduleId:this.#s,serviceIdentifier:this.#o,targetServiceIdentifier:i,type:r.ServiceRedirection};this.#n(e)}#r(i){return{arguments:(i??[]).map((i=>function(i){return\"object\"==typeof i&&!n.is(i)}(i)?{kind:!0===i.isMultiple?d.multipleInjection:d.singleInjection,name:i.name,optional:i.optional??!1,tags:new Map((i.tags??[]).map((i=>[i.key,i.value]))),value:i.serviceIdentifier}:{kind:d.singleInjection,name:void 0,optional:!1,tags:new Map,value:i}))}}}class D{#t;constructor(i){this.#t=i}onActivation(i){return this.#t.onActivation=i,new k(this.#t)}onDeactivation(i){return this.#t.onDeactivation=i,new k(this.#t)}}class k{#t;constructor(i){this.#t=i}when(i){return this.#t.isSatisfiedBy=i,new D(this.#t)}whenAnyAncestor(i){return this.when(A(i))}whenAnyAncestorIs(i){return this.when(A(R(i)))}whenAnyAncestorNamed(i){return this.when(function(i){return A(P(i))}(i))}whenAnyAncestorTagged(i,e){return this.when(function(i,e){return A(B(i,e))}(i,e))}whenDefault(){return this.when(C)}whenNamed(i){return this.when(P(i))}whenNoParent(i){return this.when(N(i))}whenNoParentIs(i){return this.when(N(R(i)))}whenNoParentNamed(i){return this.when(function(i){return N(P(i))}(i))}whenNoParentTagged(i,e){return this.when(function(i,e){return N(B(i,e))}(i,e))}whenParent(i){return this.when(x(i))}whenParentIs(i){return this.when(x(R(i)))}whenParentNamed(i){return this.when(function(i){return x(P(i))}(i))}whenParentTagged(i,e){return this.when(function(i,e){return x(B(i,e))}(i,e))}whenTagged(i,e){return this.when(B(i,e))}whenNoAncestor(i){return this.when(M(i))}whenNoAncestorIs(i){return this.when(M(R(i)))}whenNoAncestorNamed(i){return this.when(function(i){return M(P(i))}(i))}whenNoAncestorTagged(i,e){return this.when(function(i,e){return M(B(i,e))}(i,e))}}class j extends k{#c;constructor(i){super(i),this.#c=new D(i)}onActivation(i){return this.#c.onActivation(i)}onDeactivation(i){return this.#c.onDeactivation(i)}}class E extends j{#d;constructor(i){super(i),this.#d=new O(i)}inRequestScope(){return this.#d.inRequestScope()}inSingletonScope(){return this.#d.inSingletonScope()}inTransientScope(){return this.#d.inTransientScope()}}const T=Symbol.for(\"@inversifyjs/container/InversifyContainerError\");class V extends Error{[T];kind;constructor(i,e,t){super(e,t),this[T]=!0,this.kind=i}static is(i){return\"object\"==typeof i&&null!==i&&!0===i[T]}static isErrorOfKind(i,e){return V.is(i)&&i.kind===e}}var _;!function(i){i[i.invalidOperation=0]=\"invalidOperation\"}(_||(_={}));const G=c.Transient;class q{#l;#u;#h;#v;#g;#b;#S;#p;#f;#m;constructor(i){this.#v=i=>this.#l.get(i),this.#S=new l,this.#p=this.#y(),void 0===i?.parent?(this.#l=u.build(void 0),this.#u=h.build(void 0),this.#h=v.build(void 0)):(this.#l=u.build(i.parent.#l),this.#u=h.build(i.parent.#u),this.#h=v.build(i.parent.#h),i.parent.#S.subscribe(this.#S)),this.#g=this.#u.get.bind(this.#u),this.#f=this.#w.bind(this),this.#b={autobind:i?.autobind??!1,defaultScope:i?.defaultScope??G},this.#m=[]}bind(i){return new F((i=>{this.#w(i)}),void 0,this.#b.defaultScope,i)}get(i,e){const t=this.#I(!1,i,e),n=this.#A(t);if(s(n))throw new V(_.invalidOperation,`Unexpected asyncronous service when resolving service \"${a(i)}\"`);return n}getAll(i,e){const t=this.#I(!0,i,e),n=this.#A(t);if(s(n))throw new V(_.invalidOperation,`Unexpected asyncronous service when resolving service \"${a(i)}\"`);return n}async getAllAsync(i,e){const t=this.#I(!0,i,e);return this.#A(t)}async getAsync(i,e){const t=this.#I(!1,i,e);return this.#A(t)}isBound(i,e){const t=this.#u.get(i);return this.#P(i,t,e)}isCurrentBound(i,e){const t=this.#u.getNonParentBindings(i);return this.#P(i,t,e)}async load(...i){await Promise.all(i.map((async i=>i.load(this.#R(i.id)))))}onActivation(i,e){this.#l.add(e,{serviceId:i})}onDeactivation(i,e){this.#h.add(e,{serviceId:i})}restore(){const i=this.#m.pop();if(void 0===i)throw new V(_.invalidOperation,\"No snapshot available to restore\");this.#l=i.activationService,this.#u=i.bindingService,this.#h=i.deactivationService,this.#B()}snapshot(){this.#m.push({activationService:this.#l.clone(),bindingService:this.#u.clone(),deactivationService:this.#h.clone()})}async unbind(i){await g(this.#C(),i),this.#l.removeAllByServiceId(i),this.#u.removeAllByServiceId(i),this.#h.removeAllByServiceId(i),this.#S.clearCache()}async unbindAll(){const i=this.#C(),e=[...this.#u.getNonParentBoundServices()];await Promise.all(e.map((async e=>g(i,e))));for(const i of e)this.#l.removeAllByServiceId(i),this.#u.removeAllByServiceId(i),this.#h.removeAllByServiceId(i);this.#S.clearCache()}async unload(...i){const e=this.#C();await Promise.all(i.map((i=>b(e,i.id))));for(const e of i)this.#l.removeAllByModuleId(e.id),this.#u.removeAllByModuleId(e.id),this.#h.removeAllByModuleId(e.id);this.#S.clearCache()}#R(i){return{bind:e=>new F((i=>{this.#w(i)}),i,this.#b.defaultScope,e),isBound:this.isBound.bind(this),onActivation:(e,t)=>{this.#l.add(t,{moduleId:i,serviceId:e})},onDeactivation:(e,t)=>{this.#h.add(t,{moduleId:i,serviceId:e})},unbind:this.unbind.bind(this)}}#C(){return{getBindings:i=>this.#u.get(i),getBindingsFromModule:i=>this.#u.getByModuleId(i),getClassMetadata:o,getDeactivations:i=>this.#h.get(i)}}#M(i,e,t){return{isMultiple:i,name:t?.name,optional:t?.optional,serviceIdentifier:e,tag:t?.tag}}#N(i,e,t){const n={autobindOptions:t?.autobind??this.#b.autobind?{scope:this.#b.defaultScope}:void 0,getBindings:this.#g,getClassMetadata:o,rootConstraints:{isMultiple:i,serviceIdentifier:e},servicesBranch:new Set,setBinding:this.#f};return this.#x(n,t),n}#I(i,e,t){const n=this.#M(i,e,t),s=this.#S.get(n);if(void 0!==s)return s;const a=S(this.#N(i,e,t));return this.#S.set(n,a),a}#y(){return{get:this.get.bind(this),getAll:this.getAll.bind(this),getAllAsync:this.getAllAsync.bind(this),getAsync:this.getAsync.bind(this)}}#A(i){return p({context:this.#p,getActivations:this.#v,planResult:i,requestScopeCache:new Map})}#x(i,e){void 0!==e&&(void 0!==e.name&&(i.rootConstraints.name=e.name),!0===e.optional&&(i.rootConstraints.isOptional=!0),void 0!==e.tag&&(i.rootConstraints.tag={key:e.tag.key,value:e.tag.value}))}#P(i,e,t){if(void 0===e)return!1;const n={getAncestor:()=>{},name:t?.name,serviceIdentifier:i,tags:new Map};void 0!==t?.tag&&n.tags.set(t.tag.key,t.tag.value);for(const i of e)if(i.isSatisfiedBy(n))return!0;return!1}#B(){this.#S.clearCache(),this.#v=i=>this.#l.get(i),this.#g=this.#u.get.bind(this.#u),this.#p=this.#y(),this.#f=this.#w.bind(this)}#w(i){this.#u.set(i),this.#S.clearCache()}}export{q as Container,m as ContainerModule,V as InversifyContainerError,_ as InversifyContainerErrorKind};\n//# sourceMappingURL=index.js.map\n","import{getOwnReflectMetadata as e,updateOwnReflectMetadata as t,setReflectMetadata as n}from\"@inversifyjs/reflect-metadata-utils\";import{getBaseType as i}from\"@inversifyjs/prototype-utils\";import{stringifyServiceIdentifier as o,LazyServiceIdentifier as r,isPromise as a}from\"@inversifyjs/common\";const s={Request:\"Request\",Singleton:\"Singleton\",Transient:\"Transient\"},c={ConstantValue:\"ConstantValue\",DynamicValue:\"DynamicValue\",Factory:\"Factory\",Instance:\"Instance\",Provider:\"Provider\",ResolvedValue:\"ResolvedValue\",ServiceRedirection:\"ServiceRedirection\"};function*u(...e){for(const t of e)yield*t}class d{#e;#t;#n;constructor(e){this.#e=new Map,this.#t={};for(const t of Reflect.ownKeys(e))this.#t[t]=new Map;this.#n=e}add(e,t){this.#i(e).push(t);for(const n of Reflect.ownKeys(t))this.#o(n,t[n]).push(e)}clone(){const e=Reflect.ownKeys(this.#n),t=new d(this.#n);this.#r(this.#e,t.#e);for(const n of e)this.#r(this.#t[n],t.#t[n]);return t}get(e,t){return this.#t[e].get(t)}getAllKeys(e){return this.#t[e].keys()}removeByRelation(e,t){const n=this.get(e,t);if(void 0===n)return;const i=new Set(n);for(const n of i){const i=this.#e.get(n);if(void 0===i)throw new Error(\"Expecting model relation, none found\");for(const o of i)o[e]===t&&this.#a(n,o);this.#e.delete(n)}}#i(e){let t=this.#e.get(e);return void 0===t&&(t=[],this.#e.set(e,t)),t}#o(e,t){let n=this.#t[e].get(t);return void 0===n&&(n=[],this.#t[e].set(t,n)),n}#r(e,t){for(const[n,i]of e)t.set(n,[...i])}#a(e,t){for(const n of Reflect.ownKeys(t))this.#s(e,n,t[n])}#s(e,t,n){const i=this.#t[t].get(n);if(void 0!==i){const o=i.indexOf(e);-1!==o&&i.splice(o,1),0===i.length&&this.#t[t].delete(n)}}}var l,p,f;!function(e){e.moduleId=\"moduleId\",e.serviceId=\"serviceId\"}(l||(l={}));class g{#c;#u;constructor(e,t){this.#c=t??new d({moduleId:{isOptional:!0},serviceId:{isOptional:!1}}),this.#u=e}static build(e){return new g(e)}add(e,t){this.#c.add(e,t)}clone(){return new g(this.#u,this.#c.clone())}get(e){const t=[],n=this.#c.get(l.serviceId,e);void 0!==n&&t.push(n);const i=this.#u?.get(e);if(void 0!==i&&t.push(i),0!==t.length)return u(...t)}removeAllByModuleId(e){this.#c.removeByRelation(l.moduleId,e)}removeAllByServiceId(e){this.#c.removeByRelation(l.serviceId,e)}}!function(e){e.moduleId=\"moduleId\",e.serviceId=\"serviceId\"}(p||(p={}));class m{#d;#u;constructor(e,t){this.#d=t??new d({moduleId:{isOptional:!0},serviceId:{isOptional:!1}}),this.#u=e}static build(e){return new m(e)}clone(){return new m(this.#u,this.#d.clone())}get(e){return this.getNonParentBindings(e)??this.#u?.get(e)}getNonParentBindings(e){return this.#d.get(p.serviceId,e)}getNonParentBoundServices(){return this.#d.getAllKeys(p.serviceId)}getByModuleId(e){return this.#d.get(p.moduleId,e)??this.#u?.getByModuleId(e)}removeAllByModuleId(e){this.#d.removeByRelation(p.moduleId,e)}removeAllByServiceId(e){this.#d.removeByRelation(p.serviceId,e)}set(e){const t={[p.serviceId]:e.serviceIdentifier};void 0!==e.moduleId&&(t[p.moduleId]=e.moduleId),this.#d.add(e,t)}}!function(e){e.moduleId=\"moduleId\",e.serviceId=\"serviceId\"}(f||(f={}));class h{#l;#u;constructor(e,t){this.#l=t??new d({moduleId:{isOptional:!0},serviceId:{isOptional:!1}}),this.#u=e}static build(e){return new h(e)}add(e,t){this.#l.add(e,t)}clone(){return new h(this.#u,this.#l.clone())}get(e){const t=[],n=this.#l.get(f.serviceId,e);void 0!==n&&t.push(n);const i=this.#u?.get(e);if(void 0!==i&&t.push(i),0!==t.length)return u(...t)}removeAllByModuleId(e){this.#l.removeByRelation(f.moduleId,e)}removeAllByServiceId(e){this.#l.removeByRelation(f.serviceId,e)}}function v(e,t,n){const i=Array.isArray(e)?e:[e];if(void 0!==n)if(\"number\"!=typeof n)Reflect.decorate(i,t.prototype,n);else for(const e of i)e(t,void 0,n);else Reflect.decorate(i,t)}const y=\"@inversifyjs/core/classMetadataReflectKey\";function M(){return{constructorArguments:[],lifecycle:{postConstructMethodName:void 0,preDestroyMethodName:void 0},properties:new Map,scope:void 0}}const I=\"@inversifyjs/core/pendingClassMetadataCountReflectKey\";const w=Symbol.for(\"@inversifyjs/core/InversifyCoreError\");class b extends Error{[w];kind;constructor(e,t,n){super(t,n),this[w]=!0,this.kind=e}static is(e){return\"object\"==typeof e&&null!==e&&!0===e[w]}static isErrorOfKind(e,t){return b.is(e)&&e.kind===t}}var j,T,C;function S(t){const n=e(t,y)??M();if(!function(t){const n=e(t,I);return void 0!==n&&0!==n}(t))return function(e,t){const n=[];if(t.length<e.length)throw new b(j.missingInjectionDecorator,`Found unexpected missing metadata on type \"${e.name}\". \"${e.name}\" constructor requires at least ${e.length.toString()} arguments, found ${t.length.toString()} instead.\\nAre you using @inject, @multiInject or @unmanaged decorators in every non optional constructor argument?\\n\\nIf you're using typescript and want to rely on auto injection, set \"emitDecoratorMetadata\" compiler option to true`);for(let e=0;e<t.length;++e)void 0===t[e]&&n.push(e);if(n.length>0)throw new b(j.missingInjectionDecorator,`Found unexpected missing metadata on type \"${e.name}\" at constructor indexes \"${n.join('\", \"')}\".\\n\\nAre you using @inject, @multiInject or @unmanaged decorators at those indexes?\\n\\nIf you're using typescript and want to rely on auto injection, set \"emitDecoratorMetadata\" compiler option to true`)}(t,n.constructorArguments),n;!function(e,t){const n=[];for(let i=0;i<t.constructorArguments.length;++i){const o=t.constructorArguments[i];void 0!==o&&o.kind!==T.unknown||n.push(`  - Missing or incomplete metadata for type \"${e.name}\" at constructor argument with index ${i.toString()}.\\nEvery constructor parameter must be decorated either with @inject, @multiInject or @unmanaged decorator.`)}for(const[i,o]of t.properties)o.kind===T.unknown&&n.push(`  - Missing or incomplete metadata for type \"${e.name}\" at property \"${i.toString()}\".\\nThis property must be decorated either with @inject or @multiInject decorator.`);if(0===n.length)throw new b(j.unknown,`Unexpected class metadata for type \"${e.name}\" with uncompletion traces.\\nThis might be caused by one of the following reasons:\\n\\n1. A third party library is targeting inversify reflection metadata.\\n2. A bug is causing the issue. Consider submiting an issue to fix it.`);throw new b(j.missingInjectionDecorator,`Invalid class metadata at type ${e.name}:\\n\\n${n.join(\"\\n\\n\")}`)}(t,n)}function A(){return 0}function $(e){return n=>{void 0!==n&&n.kind===T.unknown&&t(e,I,A,(e=>e-1))}}function x(e,t){return(...n)=>i=>{if(void 0===i)return e(...n);if(i.kind===C.unmanaged)throw new b(j.injectionDecoratorConflict,\"Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found\");return t(i,...n)}}function B(e){if(e.kind!==T.unknown&&!0!==e.isFromTypescriptParamType)throw new b(j.injectionDecoratorConflict,\"Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found\")}!function(e){e[e.injectionDecoratorConflict=0]=\"injectionDecoratorConflict\",e[e.missingInjectionDecorator=1]=\"missingInjectionDecorator\",e[e.planning=2]=\"planning\",e[e.resolution=3]=\"resolution\",e[e.unknown=4]=\"unknown\"}(j||(j={})),function(e){e[e.unknown=32]=\"unknown\"}(T||(T={})),function(e){e[e.multipleInjection=0]=\"multipleInjection\",e[e.singleInjection=1]=\"singleInjection\",e[e.unmanaged=2]=\"unmanaged\"}(C||(C={}));const R=x((function(e,t){return{kind:e,name:void 0,optional:!1,tags:new Map,value:t}}),(function(e,t,n){return B(e),{...e,kind:t,value:n}}));function k(e,t){return n=>{const i=n.properties.get(t);return n.properties.set(t,e(i)),n}}var P;function D(e,t,n,i){if(b.isErrorOfKind(i,j.injectionDecoratorConflict)){const o=function(e,t,n){if(void 0===n){if(void 0===t)throw new b(j.unknown,\"Unexpected undefined property and index values\");return{kind:P.property,property:t,targetClass:e.constructor}}return\"number\"==typeof n?{index:n,kind:P.parameter,targetClass:e}:{kind:P.method,method:t,targetClass:e}}(e,t,n);throw new b(j.injectionDecoratorConflict,`Unexpected injection error.\\n\\nCause:\\n\\n${i.message}\\n\\nDetails\\n\\n${function(e){switch(e.kind){case P.method:return`[class: \"${e.targetClass.name}\", method: \"${e.method.toString()}\"]`;case P.parameter:return`[class: \"${e.targetClass.name}\", index: \"${e.index.toString()}\"]`;case P.property:return`[class: \"${e.targetClass.name}\", property: \"${e.property.toString()}\"]`}}(o)}`,{cause:i})}throw i}function V(e,n){return(i,o,r)=>{try{void 0===r?function(e,n){const i=F(e,n);return(e,n)=>{t(e.constructor,y,M,k(i(e),n))}}(e,n)(i,o):\"number\"==typeof r?function(e,n){const i=F(e,n);return(e,n,o)=>{if(!function(e,t){return\"function\"==typeof e&&void 0===t}(e,n))throw new b(j.injectionDecoratorConflict,`Found an @inject decorator in a non constructor parameter.\\nFound @inject decorator at method \"${n?.toString()??\"\"}\" at class \"${e.constructor.name}\"`);t(e,y,M,function(e,t){return n=>{const i=n.constructorArguments[t];return n.constructorArguments[t]=e(i),n}}(i(e),o))}}(e,n)(i,o,r):function(e,n){const i=F(e,n);return(e,n,o)=>{if(!function(e){return void 0!==e.set}(o))throw new b(j.injectionDecoratorConflict,`Found an @inject decorator in a non setter property method.\\nFound @inject decorator at method \"${n.toString()}\" at class \"${e.constructor.name}\"`);t(e.constructor,y,M,k(i(e),n))}}(e,n)(i,o,r)}catch(e){D(i,o,r,e)}}}function F(e,t){return n=>{const i=t(n);return t=>(i(t),e(t))}}function O(e){return V(R(C.singleInjection,e),$)}!function(e){e[e.method=0]=\"method\",e[e.parameter=1]=\"parameter\",e[e.property=2]=\"property\"}(P||(P={}));const N=\"@inversifyjs/core/classIsInjectableFlagReflectKey\";const E=[Array,BigInt,Boolean,Function,Number,Object,String];function U(n){const i=e(n,\"design:paramtypes\");void 0!==i&&t(n,y,M,function(e){return t=>(e.forEach(((e,n)=>{var i;void 0!==t.constructorArguments[n]||(i=e,E.includes(i))||(t.constructorArguments[n]=function(e){return{isFromTypescriptParamType:!0,kind:C.singleInjection,name:void 0,optional:!1,tags:new Map,value:e}}(e))})),t)}(i))}function K(i){return o=>{!function(t){if(void 0!==e(t,N))throw new b(j.injectionDecoratorConflict,`Cannot apply @injectable decorator multiple times at class \"${t.name}\"`);n(t,N,!0)}(o),U(o),void 0!==i&&t(o,y,M,(e=>({...e,scope:i})))}}function q(e,t,n){let i;return e.extendConstructorArguments??!0?(i=[...t.constructorArguments],n.constructorArguments.map(((e,t)=>{i[t]=e}))):i=n.constructorArguments,i}function z(e,t,n){let i;return i=e.extendProperties??!0?new Map(u(t.properties,n.properties)):n.properties,i}function G(e){return n=>{const i=S(e.type);t(n,y,M,function(e,t){const n=n=>({constructorArguments:q(e,t,n),lifecycle:n.lifecycle,properties:z(e,t,n),scope:n.scope});return n}(e,i))}}function H(e){return t=>{const n=i(t);if(void 0===n)throw new b(j.injectionDecoratorConflict,`Expected base type for type \"${t.name}\", none found.`);G({...e,type:n})(t)}}function J(e){return V(R(C.multipleInjection,e),$)}function L(e){return n=>{void 0===n&&t(e,I,A,(e=>e+1))}}function Q(e){return t=>{const n=t??{kind:T.unknown,name:void 0,optional:!1,tags:new Map};if(n.kind===C.unmanaged)throw new b(j.injectionDecoratorConflict,\"Unexpected injection found. Found @unmanaged injection with additional @named, @optional, @tagged or @targetName injections\");return e(n)}}function W(e){const t=Q(function(e){return t=>{if(void 0!==t.name)throw new b(j.injectionDecoratorConflict,\"Unexpected duplicated named decorator\");return t.name=e,t}}(e));return V(t,L)}function X(e){if(e.optional)throw new b(j.injectionDecoratorConflict,\"Unexpected duplicated optional decorator\");return e.optional=!0,e}function Y(){return V(Q(X),L)}function Z(){return(e,n,i)=>{try{t(e.constructor,y,M,(o=n,e=>{if(void 0!==e.lifecycle.postConstructMethodName)throw new b(j.injectionDecoratorConflict,\"Unexpected duplicated postConstruct decorator\");return e.lifecycle.postConstructMethodName=o,e}))}catch(t){D(e,n,void 0,t)}var o}}function _(){return(e,n,i)=>{try{t(e.constructor,y,M,(o=n,e=>{if(void 0!==e.lifecycle.preDestroyMethodName)throw new b(j.injectionDecoratorConflict,\"Unexpected duplicated preDestroy decorator\");return e.lifecycle.preDestroyMethodName=o,e}))}catch(t){D(e,n,void 0,t)}var o}}function ee(e,t){const n=Q(function(e,t){return n=>{if(n.tags.has(e))throw new b(j.injectionDecoratorConflict,\"Unexpected duplicated tag decorator with existing tag\");return n.tags.set(e,t),n}}(e,t));return V(n,L)}function te(){return{kind:C.unmanaged}}const ne=x(te,(function(e){if(B(e),function(e){return void 0!==e.name||e.optional||e.tags.size>0}(e))throw new b(j.injectionDecoratorConflict,\"Unexpected injection found. Found @unmanaged injection with additional @named, @optional, @tagged or @targetName injections\");return te()}));function ie(){return V(ne(),$)}var oe;!function(e){e[e.multipleInjection=0]=\"multipleInjection\",e[e.singleInjection=1]=\"singleInjection\"}(oe||(oe={}));class re{#p;constructor(e){this.#p=e}get name(){return this.#p.elem.name}get serviceIdentifier(){return this.#p.elem.serviceIdentifier}get tags(){return this.#p.elem.tags}getAncestor(){if(void 0!==this.#p.previous)return new re(this.#p.previous)}}class ae{last;constructor(e){this.last=e}concat(e){return new ae({elem:e,previous:this.last})}[Symbol.iterator](){let e=this.last;return{next:()=>{if(void 0===e)return{done:!0,value:void 0};const t=e.elem;return e=e.previous,{done:!1,value:t}}}}}function se(e,t){e.servicesBranch.has(t)&&function(e,t){const n=(i=[...e.servicesBranch,t],[...i].map(o).join(\" -> \"));var i;throw new b(j.planning,`Circular dependency found: ${n}`)}(e,t),e.servicesBranch.add(t)}function ce(e,t,n){const i=n?.customServiceIdentifier??t.serviceIdentifier,o=[...e.getBindings(i)??[]].filter((e=>e.isSatisfiedBy(t)));if(0===o.length&&void 0!==e.autobindOptions&&\"function\"==typeof i){const t=function(e,t){return{cache:{isRight:!1,value:void 0},id:0,implementationType:t,isSatisfiedBy:()=>!0,moduleId:void 0,onActivation:void 0,onDeactivation:void 0,scope:e.scope,serviceIdentifier:t,type:c.Instance}}(e.autobindOptions,i);e.setBinding(t),o.push(t)}return o}function ue(e){return void 0!==e.redirections}function de(e,t,n,i){let r,a;ue(n)?(r=n.binding.targetServiceIdentifier,a=n.binding.serviceIdentifier):(r=n.serviceIdentifier,a=n.parent?.binding.serviceIdentifier),Array.isArray(e)?function(e,t,n,i,r){if(0!==e.length){const t=`Ambiguous bindings found for service: \"${o(n)}\".\\n\\nRegistered bindings:\\n\\n${e.map((e=>function(e){switch(e.type){case c.Instance:return`[ type: \"${e.type}\", serviceIdentifier: \"${o(e.serviceIdentifier)}\", scope: \"${e.scope}\", implementationType: \"${e.implementationType.name}\" ]`;case c.ServiceRedirection:return`[ type: \"${e.type}\", serviceIdentifier: \"${o(e.serviceIdentifier)}\", redirection: \"${o(e.targetServiceIdentifier)}\" ]`;default:return`[ type: \"${e.type}\", serviceIdentifier: \"${o(e.serviceIdentifier)}\", scope: \"${e.scope}\" ]`}}(e.binding))).join(\"\\n\")}\\n\\nTrying to resolve bindings for \"${pe(n,i)}\".\\n\\n${fe(r)}`;throw new b(j.planning,t)}t||le(n,i,r)}(e,t,r,a,i):function(e,t,n,i,o){if(void 0!==e||t)return;le(n,i,o)}(e,t,r,a,i)}function le(e,t,n){const i=`No bindings found for service: \"${o(e)}\".\\n\\nTrying to resolve bindings for \"${pe(e,t)}\".\\n\\n${fe(n)}`;throw new b(j.planning,i)}function pe(e,t){return void 0===t?`${o(e)} (Root service)`:o(t)}function fe(e){const t=0===e.tags.size?\"\":`\\n- tags:\\n  - ${[...e.tags.keys()].map((e=>e.toString())).join(\"\\n  - \")}`;return`Binding constraints:\\n- service identifier: ${o(e.serviceIdentifier)}\\n- name: ${e.name?.toString()??\"-\"}${t}`}function ge(e,t,n){if(1!==e.redirections.length)de(e.redirections,t,e,n);else{const[i]=e.redirections;ue(i)&&ge(i,t,n)}}function me(e,t,n){if(Array.isArray(e.bindings)&&1===e.bindings.length){const[i]=e.bindings;ue(i)&&ge(i,t,n)}else de(e.bindings,t,e,n)}function he(e){const t=new Map;void 0!==e.rootConstraints.tag&&t.set(e.rootConstraints.tag.key,e.rootConstraints.tag.value);const n=new ae({elem:{name:e.rootConstraints.name,serviceIdentifier:e.rootConstraints.serviceIdentifier,tags:t},previous:void 0}),i=new re(n.last),o=ce(e,i),r=[],a={bindings:r,parent:void 0,serviceIdentifier:e.rootConstraints.serviceIdentifier};if(r.push(...we(e,n,o,a)),!e.rootConstraints.isMultiple){me(a,e.rootConstraints.isOptional??!1,i);const[t]=r;a.bindings=t}return{tree:{root:a}}}function ve(e,t,n,i){const o={binding:t,classMetadata:e.getClassMetadata(t.implementationType),constructorParams:[],parent:i,propertyParams:new Map};return je({autobindOptions:e.autobindOptions,getBindings:e.getBindings,getClassMetadata:e.getClassMetadata,node:o,servicesBranch:e.servicesBranch,setBinding:e.setBinding},n)}function ye(e,t,n){if(n.kind===C.unmanaged)return;const i=r.is(n.value)?n.value.unwrap():n.value,o=t.concat({name:n.name,serviceIdentifier:i,tags:n.tags}),a=new re(o.last),s=ce(e,a),c=[],u={bindings:c,parent:e.node,serviceIdentifier:i};if(c.push(...we(e,o,s,u)),n.kind===C.singleInjection){me(u,n.optional,a);const[e]=c;u.bindings=e}return u}function Me(e,t,n){const i=r.is(n.value)?n.value.unwrap():n.value,o=t.concat({name:n.name,serviceIdentifier:i,tags:n.tags}),a=new re(o.last),s=ce(e,a),c=[],u={bindings:c,parent:e.node,serviceIdentifier:i};if(c.push(...we(e,o,s,u)),n.kind===oe.singleInjection){me(u,n.optional,a);const[e]=c;u.bindings=e}return u}function Ie(e,t,n,i){const o={binding:t,params:[],parent:i};return je({autobindOptions:e.autobindOptions,getBindings:e.getBindings,getClassMetadata:e.getClassMetadata,node:o,servicesBranch:e.servicesBranch,setBinding:e.setBinding},n)}function we(e,t,n,i){const o=ue(i)?i.binding.targetServiceIdentifier:i.serviceIdentifier;se(e,o);const r=[];for(const o of n)switch(o.type){case c.Instance:r.push(ve(e,o,t,i));break;case c.ResolvedValue:r.push(Ie(e,o,t,i));break;case c.ServiceRedirection:{const n=be(e,t,o,i);r.push(n);break}default:r.push({binding:o,parent:i})}return e.servicesBranch.delete(o),r}function be(e,t,n,i){const o={binding:n,parent:i,redirections:[]},r=ce(e,new re(t.last),{customServiceIdentifier:n.targetServiceIdentifier});return o.redirections.push(...we(e,t,r,o)),o}function je(e,t){return e.node.binding.type===c.Instance?function(e,t,n){const i=t.classMetadata;for(const[o,r]of i.constructorArguments.entries())t.constructorParams[o]=ye(e,n,r);for(const[o,r]of i.properties){const i=ye(e,n,r);void 0!==i&&t.propertyParams.set(o,i)}return e.node}(e,e.node,t):function(e,t,n){const i=t.binding.metadata;for(const[o,r]of i.arguments.entries())t.params[o]=Me(e,n,r);return e.node}(e,e.node,t)}var Te;!function(e){e[e.singleMandatory=0]=\"singleMandatory\",e[e.singleOptional=1]=\"singleOptional\",e[e.multipleMandatory=2]=\"multipleMandatory\",e[e.multipleOptional=3]=\"multipleOptional\",e[e.length=4]=\"length\"}(Te||(Te={}));class Ce{#f;#g;#m;#h;#v;constructor(){this.#f=this.#y(),this.#g=this.#y(),this.#h=this.#y(),this.#m=this.#y(),this.#v=[]}clearCache(){for(const e of this.#M())e.clear();for(const e of this.#v)e.clearCache()}get(e){return void 0===e.name?void 0===e.tag?this.#I(this.#f,e).get(e.serviceIdentifier):this.#I(this.#m,e).get(e.serviceIdentifier)?.get(e.tag.key)?.get(e.tag.value):void 0===e.tag?this.#I(this.#g,e).get(e.serviceIdentifier)?.get(e.name):this.#I(this.#h,e).get(e.serviceIdentifier)?.get(e.name)?.get(e.tag.key)?.get(e.tag.value)}set(e,t){void 0===e.name?void 0===e.tag?this.#I(this.#f,e).set(e.serviceIdentifier,t):this.#w(this.#w(this.#I(this.#m,e),e.serviceIdentifier),e.tag.key).set(e.tag.value,t):void 0===e.tag?this.#w(this.#I(this.#g,e),e.serviceIdentifier).set(e.name,t):this.#w(this.#w(this.#w(this.#I(this.#h,e),e.serviceIdentifier),e.name),e.tag.key).set(e.tag.value,t)}subscribe(e){this.#v.push(e)}#y(){const e=new Array(Te.length);for(let t=0;t<e.length;++t)e[t]=new Map;return e}#w(e,t){let n=e.get(t);return void 0===n&&(n=new Map,e.set(t,n)),n}#I(e,t){return e[this.#b(t)]}#M(){return[...this.#f,...this.#g,...this.#h,...this.#m]}#b(e){return e.isMultiple?!0===e.optional?Te.multipleOptional:Te.multipleMandatory:!0===e.optional?Te.singleOptional:Te.singleMandatory}}function Se(e,t){return a(t)?t.then((t=>Ae(e,t))):Ae(e,t)}function Ae(e,t){return e.cache={isRight:!0,value:t},t}function $e(e,t,n){const i=e.getActivations(t);return void 0===i?n:a(n)?xe(e,n,i[Symbol.iterator]()):function(e,t,n){let i=t,o=n.next();for(;!0!==o.done;){const t=o.value(e.context,i);if(a(t))return xe(e,t,n);i=t,o=n.next()}return i}(e,n,i[Symbol.iterator]())}async function xe(e,t,n){let i=await t,o=n.next();for(;!0!==o.done;)i=await o.value(e.context,i),o=n.next();return i}function Be(e,t,n){let i=n;if(void 0!==t.onActivation){const n=t.onActivation;i=a(i)?i.then((t=>n(e.context,t))):n(e.context,i)}return $e(e,t.serviceIdentifier,i)}function Re(e){return(t,n)=>{if(n.cache.isRight)return n.cache.value;return Se(n,Be(t,n,e(t,n)))}}const ke=Re((function(e,t){return t.value}));function Pe(e){return e}function De(e,t){return(n,i)=>{const o=e(i);switch(o.scope){case s.Singleton:if(o.cache.isRight)return o.cache.value;return Se(o,Be(n,o,t(n,i)));case s.Request:{if(n.requestScopeCache.has(o.id))return n.requestScopeCache.get(o.id);const e=Be(n,o,t(n,i));return n.requestScopeCache.set(o.id,e),e}case s.Transient:return Be(n,o,t(n,i))}}}const Ve=(e=>De(Pe,e))((function(e,t){return t.value(e.context)}));const Fe=Re((function(e,t){return t.factory(e.context)}));function Oe(e,t,n){const i=function(e,t,n){if(void 0===n)return;if(!(n in e))throw new b(j.resolution,`Expecting a \"${n.toString()}\" property when resolving \"${t.implementationType.name}\" class @postConstruct decorated method, none found.`);if(\"function\"!=typeof e[n])throw new b(j.resolution,`Expecting a \"${n.toString()}\" method when resolving \"${t.implementationType.name}\" class @postConstruct decorated method, a non function property was found instead.`);{let i;try{i=e[n]()}catch(e){throw new b(j.resolution,`Unexpected error found when calling \"${n.toString()}\" @postConstruct decorated method on class \"${t.implementationType.name}\"`,{cause:e})}if(a(i))return async function(e,t,n){try{await n}catch(n){throw new b(j.resolution,`Unexpected error found when calling \"${t.toString()}\" @postConstruct decorated method on class \"${e.implementationType.name}\"`,{cause:n})}}(t,n,i)}}(e,t,n);return a(i)?i.then((()=>e)):e}function Ne(e){return(t,n,i)=>{const o=new i.binding.implementationType(...t),r=e(n,o,i);return a(r)?r.then((()=>Oe(o,i.binding,i.classMetadata.lifecycle.postConstructMethodName))):Oe(o,i.binding,i.classMetadata.lifecycle.postConstructMethodName)}}const Ee=Re((function(e,t){return t.provider(e.context)}));function Ue(e){return e.binding}function Ke(e){return e.binding}const qe=function(e){return(t,n,i)=>{const o=[];for(const[r,s]of i.propertyParams){const c=i.classMetadata.properties.get(r);if(void 0===c)throw new b(j.resolution,`Expecting metadata at property \"${r.toString()}\", none found`);c.kind!==C.unmanaged&&void 0!==s.bindings&&(n[r]=e(t,s),a(n[r])&&o.push((async()=>{n[r]=await n[r]})()))}if(o.length>0)return Promise.all(o).then((()=>{}))}}(Xe),ze=function(e){return function t(n,i){const o=[];for(const r of i.redirections)ue(r)?o.push(...t(n,r)):o.push(e(n,r));return o}}(We),Ge=function(e,t,n){return(i,o)=>{const r=e(i,o);return a(r)?t(r,i,o):n(r,i,o)}}(function(e){return(t,n)=>{const i=[];for(const o of n.constructorParams)void 0===o?i.push(void 0):i.push(e(t,o));return i.some(a)?Promise.all(i):i}}(Xe),function(e){return async(t,n,i)=>{const o=await t;return e(o,n,i)}}(Ne(qe)),Ne(qe)),He=function(e){return(t,n)=>{const i=e(t,n);return a(i)?i.then((e=>n.binding.factory(...e))):n.binding.factory(...i)}}(function(e){return(t,n)=>{const i=[];for(const o of n.params)i.push(e(t,o));return i.some(a)?Promise.all(i):i}}(Xe)),Je=(e=>De(Ue,e))(Ge),Le=(e=>De(Ke,e))(He);function Qe(e){return Xe(e,e.planResult.tree.root)}function We(e,t){switch(t.binding.type){case c.ConstantValue:return ke(e,t.binding);case c.DynamicValue:return Ve(e,t.binding);case c.Factory:return Fe(e,t.binding);case c.Instance:return Je(e,t);case c.Provider:return Ee(e,t.binding);case c.ResolvedValue:return Le(e,t)}}function Xe(e,t){if(void 0!==t.bindings)return Array.isArray(t.bindings)?function(e,t){const n=[];for(const i of t)ue(i)?n.push(...ze(e,i)):n.push(We(e,i));if(n.some(a))return Promise.all(n);return n}(e,t.bindings):function(e,t){if(ue(t)){const n=ze(e,t);if(1===n.length)return n[0];throw new b(j.resolution,\"Unexpected multiple resolved values on single injection\")}return We(e,t)}(e,t.bindings)}function Ye(e){return void 0!==e.scope}function Ze(e,t){if(void 0!==e.lifecycle.preDestroyMethodName&&\"function\"==typeof t[e.lifecycle.preDestroyMethodName])return t[e.lifecycle.preDestroyMethodName]()}function _e(e,t,n){const i=e.getDeactivations(t);if(void 0!==i)return a(n)?et(n,i[Symbol.iterator]()):function(e,t){let n=t.next();for(;!0!==n.done;){const i=n.value(e);if(a(i))return et(e,t);n=t.next()}}(n,i[Symbol.iterator]())}async function et(e,t){const n=await e;let i=t.next();for(;!0!==i.done;)await i.value(n),i=t.next()}function tt(e,t){const n=function(e,t){if(t.type===c.Instance){const n=e.getClassMetadata(t.implementationType),i=t.cache.value;return a(i)?i.then((e=>Ze(n,e))):Ze(n,i)}}(e,t);return void 0===n?nt(e,t):n.then((()=>nt(e,t)))}function nt(e,t){const n=t.cache;return a(n.value)?n.value.then((n=>it(e,t,n))):it(e,t,n.value)}function it(e,t,n){let i;if(void 0!==t.onDeactivation){i=(0,t.onDeactivation)(n)}return void 0===i?_e(e,t.serviceIdentifier,n):i.then((()=>_e(e,t.serviceIdentifier,n)))}function ot(e,t){if(void 0===t)return;const n=function(e){const t=[];for(const n of e)Ye(n)&&n.scope===s.Singleton&&n.cache.isRight&&t.push(n);return t}(t),i=[];for(const t of n){const n=tt(e,t);void 0!==n&&i.push(n)}return i.length>0?Promise.all(i).then((()=>{})):void 0}function rt(e,t){const n=e.getBindingsFromModule(t);return ot(e,n)}function at(e,t){const n=e.getBindings(t);return ot(e,n)}export{g as ActivationsService,m as BindingService,C as ClassElementMetadataKind,h as DeactivationsService,Ce as PlanResultCacheService,oe as ResolvedValueElementMetadataKind,s as bindingScopeValues,c as bindingTypeValues,v as decorate,S as getClassMetadata,O as inject,H as injectFromBase,K as injectable,J as multiInject,W as named,Y as optional,he as plan,Z as postConstruct,_ as preDestroy,Qe as resolve,rt as resolveModuleDeactivations,at as resolveServiceDeactivations,ee as tagged,ie as unmanaged};\n//# sourceMappingURL=index.js.map\n","function t(t){const o=Object.getPrototypeOf(t.prototype),r=o?.constructor;return r}export{t as getBaseType};\n//# sourceMappingURL=index.js.map\n","function t(t,e){return Reflect.getOwnMetadata(e,t)}function e(t,e){return Reflect.getMetadata(e,t)}function n(t,e,n){Reflect.defineMetadata(e,n,t)}function a(e,n,a,f){const c=f(t(e,n)??a());Reflect.defineMetadata(n,c,e)}function f(t,n,a,f){const c=f(e(t,n)??a());Reflect.defineMetadata(n,c,t)}export{t as getOwnReflectMetadata,e as getReflectMetadata,n as setReflectMetadata,a as updateOwnReflectMetadata,f as updateReflectMetadata};\n//# sourceMappingURL=index.js.map\n","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController\r\n// We don't actually ever use the API being polyfilled, we always use the polyfill because\r\n// it's a very new API right now.\r\n// Not exported from index.\r\n/** @private */\r\nexport class AbortController {\r\n    constructor() {\r\n        this._isAborted = false;\r\n        this.onabort = null;\r\n    }\r\n    abort() {\r\n        if (!this._isAborted) {\r\n            this._isAborted = true;\r\n            if (this.onabort) {\r\n                this.onabort();\r\n            }\r\n        }\r\n    }\r\n    get signal() {\r\n        return this;\r\n    }\r\n    get aborted() {\r\n        return this._isAborted;\r\n    }\r\n}\r\n//# sourceMappingURL=AbortController.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { HttpClient } from \"./HttpClient\";\r\n/** @private */\r\nexport class AccessTokenHttpClient extends HttpClient {\r\n    constructor(innerClient, accessTokenFactory) {\r\n        super();\r\n        this._innerClient = innerClient;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n    }\r\n    async send(request) {\r\n        let allowRetry = true;\r\n        if (this._accessTokenFactory && (!this._accessToken || (request.url && request.url.indexOf(\"/negotiate?\") > 0))) {\r\n            // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory\r\n            allowRetry = false;\r\n            this._accessToken = await this._accessTokenFactory();\r\n        }\r\n        this._setAuthorizationHeader(request);\r\n        const response = await this._innerClient.send(request);\r\n        if (allowRetry && response.statusCode === 401 && this._accessTokenFactory) {\r\n            this._accessToken = await this._accessTokenFactory();\r\n            this._setAuthorizationHeader(request);\r\n            return await this._innerClient.send(request);\r\n        }\r\n        return response;\r\n    }\r\n    _setAuthorizationHeader(request) {\r\n        if (!request.headers) {\r\n            request.headers = {};\r\n        }\r\n        if (this._accessToken) {\r\n            request.headers[HeaderNames.Authorization] = `Bearer ${this._accessToken}`;\r\n        }\r\n        // don't remove the header if there isn't an access token factory, the user manually added the header in this case\r\n        else if (this._accessTokenFactory) {\r\n            if (request.headers[HeaderNames.Authorization]) {\r\n                delete request.headers[HeaderNames.Authorization];\r\n            }\r\n        }\r\n    }\r\n    getCookieString(url) {\r\n        return this._innerClient.getCookieString(url);\r\n    }\r\n}\r\n//# sourceMappingURL=AccessTokenHttpClient.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AbortError } from \"./Errors\";\r\nimport { FetchHttpClient } from \"./FetchHttpClient\";\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { Platform } from \"./Utils\";\r\nimport { XhrHttpClient } from \"./XhrHttpClient\";\r\n/** Default implementation of {@link @microsoft/signalr.HttpClient}. */\r\nexport class DefaultHttpClient extends HttpClient {\r\n    /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */\r\n    constructor(logger) {\r\n        super();\r\n        if (typeof fetch !== \"undefined\" || Platform.isNode) {\r\n            this._httpClient = new FetchHttpClient(logger);\r\n        }\r\n        else if (typeof XMLHttpRequest !== \"undefined\") {\r\n            this._httpClient = new XhrHttpClient(logger);\r\n        }\r\n        else {\r\n            throw new Error(\"No usable HttpClient found.\");\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    send(request) {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n        return this._httpClient.send(request);\r\n    }\r\n    getCookieString(url) {\r\n        return this._httpClient.getCookieString(url);\r\n    }\r\n}\r\n//# sourceMappingURL=DefaultHttpClient.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// 0, 2, 10, 30 second delays before reconnect attempts.\r\nconst DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];\r\n/** @private */\r\nexport class DefaultReconnectPolicy {\r\n    constructor(retryDelays) {\r\n        this._retryDelays = retryDelays !== undefined ? [...retryDelays, null] : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;\r\n    }\r\n    nextRetryDelayInMilliseconds(retryContext) {\r\n        return this._retryDelays[retryContext.previousRetryCount];\r\n    }\r\n}\r\n//# sourceMappingURL=DefaultReconnectPolicy.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n/** Error thrown when an HTTP request fails. */\r\nexport class HttpError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     * @param {number} statusCode The HTTP status code represented by this error.\r\n     */\r\n    constructor(errorMessage, statusCode) {\r\n        const trueProto = new.target.prototype;\r\n        super(`${errorMessage}: Status code '${statusCode}'`);\r\n        this.statusCode = statusCode;\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when a timeout elapses. */\r\nexport class TimeoutError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage = \"A timeout occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when an action is aborted. */\r\nexport class AbortError extends Error {\r\n    /** Constructs a new instance of {@link AbortError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage = \"An abort occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when the selected transport is unsupported by the browser. */\r\n/** @private */\r\nexport class UnsupportedTransportError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.UnsupportedTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n     */\r\n    constructor(message, transport) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'UnsupportedTransportError';\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when the selected transport is disabled by the browser. */\r\n/** @private */\r\nexport class DisabledTransportError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.DisabledTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n     */\r\n    constructor(message, transport) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'DisabledTransportError';\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when the selected transport cannot be started. */\r\n/** @private */\r\nexport class FailedToStartTransportError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.FailedToStartTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n     */\r\n    constructor(message, transport) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'FailedToStartTransportError';\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when the negotiation with the server failed to complete. */\r\n/** @private */\r\nexport class FailedToNegotiateWithServerError extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.FailedToNegotiateWithServerError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     */\r\n    constructor(message) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.errorType = 'FailedToNegotiateWithServerError';\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n/** Error thrown when multiple errors have occurred. */\r\n/** @private */\r\nexport class AggregateErrors extends Error {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.AggregateErrors}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {Error[]} innerErrors The collection of errors this error is aggregating.\r\n     */\r\n    constructor(message, innerErrors) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.innerErrors = innerErrors;\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n//# sourceMappingURL=Errors.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpResponse } from \"./HttpClient\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { Platform, getGlobalThis, isArrayBuffer } from \"./Utils\";\r\nexport class FetchHttpClient extends HttpClient {\r\n    constructor(logger) {\r\n        super();\r\n        this._logger = logger;\r\n        // Node added a fetch implementation to the global scope starting in v18.\r\n        // We need to add a cookie jar in node to be able to share cookies with WebSocket\r\n        if (typeof fetch === \"undefined\" || Platform.isNode) {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\r\n            this._jar = new (requireFunc(\"tough-cookie\")).CookieJar();\r\n            if (typeof fetch === \"undefined\") {\r\n                this._fetchType = requireFunc(\"node-fetch\");\r\n            }\r\n            else {\r\n                // Use fetch from Node if available\r\n                this._fetchType = fetch;\r\n            }\r\n            // node-fetch doesn't have a nice API for getting and setting cookies\r\n            // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\r\n            this._fetchType = requireFunc(\"fetch-cookie\")(this._fetchType, this._jar);\r\n        }\r\n        else {\r\n            this._fetchType = fetch.bind(getGlobalThis());\r\n        }\r\n        if (typeof AbortController === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\r\n            this._abortControllerType = requireFunc(\"abort-controller\");\r\n        }\r\n        else {\r\n            this._abortControllerType = AbortController;\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    async send(request) {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            throw new AbortError();\r\n        }\r\n        if (!request.method) {\r\n            throw new Error(\"No method defined.\");\r\n        }\r\n        if (!request.url) {\r\n            throw new Error(\"No url defined.\");\r\n        }\r\n        const abortController = new this._abortControllerType();\r\n        let error;\r\n        // Hook our abortSignal into the abort controller\r\n        if (request.abortSignal) {\r\n            request.abortSignal.onabort = () => {\r\n                abortController.abort();\r\n                error = new AbortError();\r\n            };\r\n        }\r\n        // If a timeout has been passed in, setup a timeout to call abort\r\n        // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\r\n        let timeoutId = null;\r\n        if (request.timeout) {\r\n            const msTimeout = request.timeout;\r\n            timeoutId = setTimeout(() => {\r\n                abortController.abort();\r\n                this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                error = new TimeoutError();\r\n            }, msTimeout);\r\n        }\r\n        if (request.content === \"\") {\r\n            request.content = undefined;\r\n        }\r\n        if (request.content) {\r\n            // Explicitly setting the Content-Type header for React Native on Android platform.\r\n            request.headers = request.headers || {};\r\n            if (isArrayBuffer(request.content)) {\r\n                request.headers[\"Content-Type\"] = \"application/octet-stream\";\r\n            }\r\n            else {\r\n                request.headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\r\n            }\r\n        }\r\n        let response;\r\n        try {\r\n            response = await this._fetchType(request.url, {\r\n                body: request.content,\r\n                cache: \"no-cache\",\r\n                credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\r\n                headers: {\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                    ...request.headers,\r\n                },\r\n                method: request.method,\r\n                mode: \"cors\",\r\n                redirect: \"follow\",\r\n                signal: abortController.signal,\r\n            });\r\n        }\r\n        catch (e) {\r\n            if (error) {\r\n                throw error;\r\n            }\r\n            this._logger.log(LogLevel.Warning, `Error from HTTP request. ${e}.`);\r\n            throw e;\r\n        }\r\n        finally {\r\n            if (timeoutId) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = null;\r\n            }\r\n        }\r\n        if (!response.ok) {\r\n            const errorMessage = await deserializeContent(response, \"text\");\r\n            throw new HttpError(errorMessage || response.statusText, response.status);\r\n        }\r\n        const content = deserializeContent(response, request.responseType);\r\n        const payload = await content;\r\n        return new HttpResponse(response.status, response.statusText, payload);\r\n    }\r\n    getCookieString(url) {\r\n        let cookies = \"\";\r\n        if (Platform.isNode && this._jar) {\r\n            // @ts-ignore: unused variable\r\n            this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\r\n        }\r\n        return cookies;\r\n    }\r\n}\r\nfunction deserializeContent(response, responseType) {\r\n    let content;\r\n    switch (responseType) {\r\n        case \"arraybuffer\":\r\n            content = response.arrayBuffer();\r\n            break;\r\n        case \"text\":\r\n            content = response.text();\r\n            break;\r\n        case \"blob\":\r\n        case \"document\":\r\n        case \"json\":\r\n            throw new Error(`${responseType} is not supported.`);\r\n        default:\r\n            content = response.text();\r\n            break;\r\n    }\r\n    return content;\r\n}\r\n//# sourceMappingURL=FetchHttpClient.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n/** @private */\r\nexport class HandshakeProtocol {\r\n    // Handshake request is always JSON\r\n    writeHandshakeRequest(handshakeRequest) {\r\n        return TextMessageFormat.write(JSON.stringify(handshakeRequest));\r\n    }\r\n    parseHandshakeResponse(data) {\r\n        let messageData;\r\n        let remainingData;\r\n        if (isArrayBuffer(data)) {\r\n            // Format is binary but still need to read JSON text from handshake response\r\n            const binaryData = new Uint8Array(data);\r\n            const separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = String.fromCharCode.apply(null, Array.prototype.slice.call(binaryData.slice(0, responseLength)));\r\n            remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;\r\n        }\r\n        else {\r\n            const textData = data;\r\n            const separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = textData.substring(0, responseLength);\r\n            remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;\r\n        }\r\n        // At this point we should have just the single handshake message\r\n        const messages = TextMessageFormat.parse(messageData);\r\n        const response = JSON.parse(messages[0]);\r\n        if (response.type) {\r\n            throw new Error(\"Expected a handshake response from the server.\");\r\n        }\r\n        const responseMessage = response;\r\n        // multiple messages could have arrived with handshake\r\n        // return additional data to be parsed as usual, or null if all parsed\r\n        return [remainingData, responseMessage];\r\n    }\r\n}\r\n//# sourceMappingURL=HandshakeProtocol.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nexport class HeaderNames {\r\n}\r\nHeaderNames.Authorization = \"Authorization\";\r\nHeaderNames.Cookie = \"Cookie\";\r\n//# sourceMappingURL=HeaderNames.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n/** Represents an HTTP response. */\r\nexport class HttpResponse {\r\n    constructor(statusCode, statusText, content) {\r\n        this.statusCode = statusCode;\r\n        this.statusText = statusText;\r\n        this.content = content;\r\n    }\r\n}\r\n/** Abstraction over an HTTP client.\r\n *\r\n * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.\r\n */\r\nexport class HttpClient {\r\n    get(url, options) {\r\n        return this.send({\r\n            ...options,\r\n            method: \"GET\",\r\n            url,\r\n        });\r\n    }\r\n    post(url, options) {\r\n        return this.send({\r\n            ...options,\r\n            method: \"POST\",\r\n            url,\r\n        });\r\n    }\r\n    delete(url, options) {\r\n        return this.send({\r\n            ...options,\r\n            method: \"DELETE\",\r\n            url,\r\n        });\r\n    }\r\n    /** Gets all cookies that apply to the specified URL.\r\n     *\r\n     * @param url The URL that the cookies are valid for.\r\n     * @returns {string} A string containing all the key-value cookie pairs for the specified URL.\r\n     */\r\n    // @ts-ignore\r\n    getCookieString(url) {\r\n        return \"\";\r\n    }\r\n}\r\n//# sourceMappingURL=HttpClient.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AccessTokenHttpClient } from \"./AccessTokenHttpClient\";\r\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\r\nimport { AggregateErrors, DisabledTransportError, FailedToNegotiateWithServerError, FailedToStartTransportError, HttpError, UnsupportedTransportError, AbortError } from \"./Errors\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { HttpTransportType, TransferFormat } from \"./ITransport\";\r\nimport { LongPollingTransport } from \"./LongPollingTransport\";\r\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\r\nimport { Arg, createLogger, getUserAgentHeader, Platform } from \"./Utils\";\r\nimport { WebSocketTransport } from \"./WebSocketTransport\";\r\nconst MAX_REDIRECTS = 100;\r\n/** @private */\r\nexport class HttpConnection {\r\n    constructor(url, options = {}) {\r\n        this._stopPromiseResolver = () => { };\r\n        this.features = {};\r\n        this._negotiateVersion = 1;\r\n        Arg.isRequired(url, \"url\");\r\n        this._logger = createLogger(options.logger);\r\n        this.baseUrl = this._resolveUrl(url);\r\n        options = options || {};\r\n        options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\r\n        if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\r\n            options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\r\n        }\r\n        else {\r\n            throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\r\n        }\r\n        options.timeout = options.timeout === undefined ? 100 * 1000 : options.timeout;\r\n        let webSocketModule = null;\r\n        let eventSourceModule = null;\r\n        if (Platform.isNode && typeof require !== \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            webSocketModule = requireFunc(\"ws\");\r\n            eventSourceModule = requireFunc(\"eventsource\");\r\n        }\r\n        if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\r\n            options.WebSocket = WebSocket;\r\n        }\r\n        else if (Platform.isNode && !options.WebSocket) {\r\n            if (webSocketModule) {\r\n                options.WebSocket = webSocketModule;\r\n            }\r\n        }\r\n        if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\r\n            options.EventSource = EventSource;\r\n        }\r\n        else if (Platform.isNode && !options.EventSource) {\r\n            if (typeof eventSourceModule !== \"undefined\") {\r\n                options.EventSource = eventSourceModule;\r\n            }\r\n        }\r\n        this._httpClient = new AccessTokenHttpClient(options.httpClient || new DefaultHttpClient(this._logger), options.accessTokenFactory);\r\n        this._connectionState = \"Disconnected\" /* ConnectionState.Disconnected */;\r\n        this._connectionStarted = false;\r\n        this._options = options;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    async start(transferFormat) {\r\n        transferFormat = transferFormat || TransferFormat.Binary;\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);\r\n        if (this._connectionState !== \"Disconnected\" /* ConnectionState.Disconnected */) {\r\n            return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n        this._connectionState = \"Connecting\" /* ConnectionState.Connecting */;\r\n        this._startInternalPromise = this._startInternal(transferFormat);\r\n        await this._startInternalPromise;\r\n        // The TypeScript compiler thinks that connectionState must be Connecting here. The TypeScript compiler is wrong.\r\n        if (this._connectionState === \"Disconnecting\" /* ConnectionState.Disconnecting */) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"Failed to start the HttpConnection before stop() was called.\";\r\n            this._logger.log(LogLevel.Error, message);\r\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\r\n            await this._stopPromise;\r\n            return Promise.reject(new AbortError(message));\r\n        }\r\n        else if (this._connectionState !== \"Connected\" /* ConnectionState.Connected */) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\r\n            this._logger.log(LogLevel.Error, message);\r\n            return Promise.reject(new AbortError(message));\r\n        }\r\n        this._connectionStarted = true;\r\n    }\r\n    send(data) {\r\n        if (this._connectionState !== \"Connected\" /* ConnectionState.Connected */) {\r\n            return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\r\n        }\r\n        if (!this._sendQueue) {\r\n            this._sendQueue = new TransportSendQueue(this.transport);\r\n        }\r\n        // Transport will not be null if state is connected\r\n        return this._sendQueue.send(data);\r\n    }\r\n    async stop(error) {\r\n        if (this._connectionState === \"Disconnected\" /* ConnectionState.Disconnected */) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n        if (this._connectionState === \"Disconnecting\" /* ConnectionState.Disconnecting */) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this._stopPromise;\r\n        }\r\n        this._connectionState = \"Disconnecting\" /* ConnectionState.Disconnecting */;\r\n        this._stopPromise = new Promise((resolve) => {\r\n            // Don't complete stop() until stopConnection() completes.\r\n            this._stopPromiseResolver = resolve;\r\n        });\r\n        // stopInternal should never throw so just observe it.\r\n        await this._stopInternal(error);\r\n        await this._stopPromise;\r\n    }\r\n    async _stopInternal(error) {\r\n        // Set error as soon as possible otherwise there is a race between\r\n        // the transport closing and providing an error and the error from a close message\r\n        // We would prefer the close message error.\r\n        this._stopError = error;\r\n        try {\r\n            await this._startInternalPromise;\r\n        }\r\n        catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n        // The transport's onclose will trigger stopConnection which will run our onclose event.\r\n        // The transport should always be set if currently connected. If it wasn't set, it's likely because\r\n        // stop was called during start() and start() failed.\r\n        if (this.transport) {\r\n            try {\r\n                await this.transport.stop();\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`);\r\n                this._stopConnection();\r\n            }\r\n            this.transport = undefined;\r\n        }\r\n        else {\r\n            this._logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\r\n        }\r\n    }\r\n    async _startInternal(transferFormat) {\r\n        // Store the original base url and the access token factory since they may change\r\n        // as part of negotiating\r\n        let url = this.baseUrl;\r\n        this._accessTokenFactory = this._options.accessTokenFactory;\r\n        this._httpClient._accessTokenFactory = this._accessTokenFactory;\r\n        try {\r\n            if (this._options.skipNegotiation) {\r\n                if (this._options.transport === HttpTransportType.WebSockets) {\r\n                    // No need to add a connection ID in this case\r\n                    this.transport = this._constructTransport(HttpTransportType.WebSockets);\r\n                    // We should just call connect directly in this case.\r\n                    // No fallback or negotiate in this case.\r\n                    await this._startTransport(url, transferFormat);\r\n                }\r\n                else {\r\n                    throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\r\n                }\r\n            }\r\n            else {\r\n                let negotiateResponse = null;\r\n                let redirects = 0;\r\n                do {\r\n                    negotiateResponse = await this._getNegotiationResponse(url);\r\n                    // the user tries to stop the connection when it is being started\r\n                    if (this._connectionState === \"Disconnecting\" /* ConnectionState.Disconnecting */ || this._connectionState === \"Disconnected\" /* ConnectionState.Disconnected */) {\r\n                        throw new AbortError(\"The connection was stopped during negotiation.\");\r\n                    }\r\n                    if (negotiateResponse.error) {\r\n                        throw new Error(negotiateResponse.error);\r\n                    }\r\n                    if (negotiateResponse.ProtocolVersion) {\r\n                        throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\r\n                    }\r\n                    if (negotiateResponse.url) {\r\n                        url = negotiateResponse.url;\r\n                    }\r\n                    if (negotiateResponse.accessToken) {\r\n                        // Replace the current access token factory with one that uses\r\n                        // the returned access token\r\n                        const accessToken = negotiateResponse.accessToken;\r\n                        this._accessTokenFactory = () => accessToken;\r\n                        // set the factory to undefined so the AccessTokenHttpClient won't retry with the same token, since we know it won't change until a connection restart\r\n                        this._httpClient._accessToken = accessToken;\r\n                        this._httpClient._accessTokenFactory = undefined;\r\n                    }\r\n                    redirects++;\r\n                } while (negotiateResponse.url && redirects < MAX_REDIRECTS);\r\n                if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\r\n                    throw new Error(\"Negotiate redirection limit exceeded.\");\r\n                }\r\n                await this._createTransport(url, this._options.transport, negotiateResponse, transferFormat);\r\n            }\r\n            if (this.transport instanceof LongPollingTransport) {\r\n                this.features.inherentKeepAlive = true;\r\n            }\r\n            if (this._connectionState === \"Connecting\" /* ConnectionState.Connecting */) {\r\n                // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\r\n                // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\r\n                this._logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\r\n                this._connectionState = \"Connected\" /* ConnectionState.Connected */;\r\n            }\r\n            // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.\r\n            // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()\r\n            // will transition to the disconnected state. start() will wait for the transition using the stopPromise.\r\n        }\r\n        catch (e) {\r\n            this._logger.log(LogLevel.Error, \"Failed to start the connection: \" + e);\r\n            this._connectionState = \"Disconnected\" /* ConnectionState.Disconnected */;\r\n            this.transport = undefined;\r\n            // if start fails, any active calls to stop assume that start will complete the stop promise\r\n            this._stopPromiseResolver();\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n    async _getNegotiationResponse(url) {\r\n        const headers = {};\r\n        const [name, value] = getUserAgentHeader();\r\n        headers[name] = value;\r\n        const negotiateUrl = this._resolveNegotiateUrl(url);\r\n        this._logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}.`);\r\n        try {\r\n            const response = await this._httpClient.post(negotiateUrl, {\r\n                content: \"\",\r\n                headers: { ...headers, ...this._options.headers },\r\n                timeout: this._options.timeout,\r\n                withCredentials: this._options.withCredentials,\r\n            });\r\n            if (response.statusCode !== 200) {\r\n                return Promise.reject(new Error(`Unexpected status code returned from negotiate '${response.statusCode}'`));\r\n            }\r\n            const negotiateResponse = JSON.parse(response.content);\r\n            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\r\n                // Negotiate version 0 doesn't use connectionToken\r\n                // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\r\n                negotiateResponse.connectionToken = negotiateResponse.connectionId;\r\n            }\r\n            if (negotiateResponse.useStatefulReconnect && this._options._useStatefulReconnect !== true) {\r\n                return Promise.reject(new FailedToNegotiateWithServerError(\"Client didn't negotiate Stateful Reconnect but the server did.\"));\r\n            }\r\n            return negotiateResponse;\r\n        }\r\n        catch (e) {\r\n            let errorMessage = \"Failed to complete negotiation with the server: \" + e;\r\n            if (e instanceof HttpError) {\r\n                if (e.statusCode === 404) {\r\n                    errorMessage = errorMessage + \" Either this is not a SignalR endpoint or there is a proxy blocking the connection.\";\r\n                }\r\n            }\r\n            this._logger.log(LogLevel.Error, errorMessage);\r\n            return Promise.reject(new FailedToNegotiateWithServerError(errorMessage));\r\n        }\r\n    }\r\n    _createConnectUrl(url, connectionToken) {\r\n        if (!connectionToken) {\r\n            return url;\r\n        }\r\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${connectionToken}`;\r\n    }\r\n    async _createTransport(url, requestedTransport, negotiateResponse, requestedTransferFormat) {\r\n        let connectUrl = this._createConnectUrl(url, negotiateResponse.connectionToken);\r\n        if (this._isITransport(requestedTransport)) {\r\n            this._logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\r\n            this.transport = requestedTransport;\r\n            await this._startTransport(connectUrl, requestedTransferFormat);\r\n            this.connectionId = negotiateResponse.connectionId;\r\n            return;\r\n        }\r\n        const transportExceptions = [];\r\n        const transports = negotiateResponse.availableTransports || [];\r\n        let negotiate = negotiateResponse;\r\n        for (const endpoint of transports) {\r\n            const transportOrError = this._resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat, (negotiate === null || negotiate === void 0 ? void 0 : negotiate.useStatefulReconnect) === true);\r\n            if (transportOrError instanceof Error) {\r\n                // Store the error and continue, we don't want to cause a re-negotiate in these cases\r\n                transportExceptions.push(`${endpoint.transport} failed:`);\r\n                transportExceptions.push(transportOrError);\r\n            }\r\n            else if (this._isITransport(transportOrError)) {\r\n                this.transport = transportOrError;\r\n                if (!negotiate) {\r\n                    try {\r\n                        negotiate = await this._getNegotiationResponse(url);\r\n                    }\r\n                    catch (ex) {\r\n                        return Promise.reject(ex);\r\n                    }\r\n                    connectUrl = this._createConnectUrl(url, negotiate.connectionToken);\r\n                }\r\n                try {\r\n                    await this._startTransport(connectUrl, requestedTransferFormat);\r\n                    this.connectionId = negotiate.connectionId;\r\n                    return;\r\n                }\r\n                catch (ex) {\r\n                    this._logger.log(LogLevel.Error, `Failed to start the transport '${endpoint.transport}': ${ex}`);\r\n                    negotiate = undefined;\r\n                    transportExceptions.push(new FailedToStartTransportError(`${endpoint.transport} failed: ${ex}`, HttpTransportType[endpoint.transport]));\r\n                    if (this._connectionState !== \"Connecting\" /* ConnectionState.Connecting */) {\r\n                        const message = \"Failed to select transport before stop() was called.\";\r\n                        this._logger.log(LogLevel.Debug, message);\r\n                        return Promise.reject(new AbortError(message));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (transportExceptions.length > 0) {\r\n            return Promise.reject(new AggregateErrors(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(\" \")}`, transportExceptions));\r\n        }\r\n        return Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\r\n    }\r\n    _constructTransport(transport) {\r\n        switch (transport) {\r\n            case HttpTransportType.WebSockets:\r\n                if (!this._options.WebSocket) {\r\n                    throw new Error(\"'WebSocket' is not supported in your environment.\");\r\n                }\r\n                return new WebSocketTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent, this._options.WebSocket, this._options.headers || {});\r\n            case HttpTransportType.ServerSentEvents:\r\n                if (!this._options.EventSource) {\r\n                    throw new Error(\"'EventSource' is not supported in your environment.\");\r\n                }\r\n                return new ServerSentEventsTransport(this._httpClient, this._httpClient._accessToken, this._logger, this._options);\r\n            case HttpTransportType.LongPolling:\r\n                return new LongPollingTransport(this._httpClient, this._logger, this._options);\r\n            default:\r\n                throw new Error(`Unknown transport: ${transport}.`);\r\n        }\r\n    }\r\n    _startTransport(url, transferFormat) {\r\n        this.transport.onreceive = this.onreceive;\r\n        if (this.features.reconnect) {\r\n            this.transport.onclose = async (e) => {\r\n                let callStop = false;\r\n                if (this.features.reconnect) {\r\n                    try {\r\n                        this.features.disconnected();\r\n                        await this.transport.connect(url, transferFormat);\r\n                        await this.features.resend();\r\n                    }\r\n                    catch {\r\n                        callStop = true;\r\n                    }\r\n                }\r\n                else {\r\n                    this._stopConnection(e);\r\n                    return;\r\n                }\r\n                if (callStop) {\r\n                    this._stopConnection(e);\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            this.transport.onclose = (e) => this._stopConnection(e);\r\n        }\r\n        return this.transport.connect(url, transferFormat);\r\n    }\r\n    _resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat, useStatefulReconnect) {\r\n        const transport = HttpTransportType[endpoint.transport];\r\n        if (transport === null || transport === undefined) {\r\n            this._logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n            return new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n        }\r\n        else {\r\n            if (transportMatches(requestedTransport, transport)) {\r\n                const transferFormats = endpoint.transferFormats.map((s) => TransferFormat[s]);\r\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\r\n                    if ((transport === HttpTransportType.WebSockets && !this._options.WebSocket) ||\r\n                        (transport === HttpTransportType.ServerSentEvents && !this._options.EventSource)) {\r\n                        this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`);\r\n                        return new UnsupportedTransportError(`'${HttpTransportType[transport]}' is not supported in your environment.`, transport);\r\n                    }\r\n                    else {\r\n                        this._logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'.`);\r\n                        try {\r\n                            this.features.reconnect = transport === HttpTransportType.WebSockets ? useStatefulReconnect : undefined;\r\n                            return this._constructTransport(transport);\r\n                        }\r\n                        catch (ex) {\r\n                            return ex;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);\r\n                    return new Error(`'${HttpTransportType[transport]}' does not support ${TransferFormat[requestedTransferFormat]}.`);\r\n                }\r\n            }\r\n            else {\r\n                this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);\r\n                return new DisabledTransportError(`'${HttpTransportType[transport]}' is disabled by the client.`, transport);\r\n            }\r\n        }\r\n    }\r\n    _isITransport(transport) {\r\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\r\n    }\r\n    _stopConnection(error) {\r\n        this._logger.log(LogLevel.Debug, `HttpConnection.stopConnection(${error}) called while in state ${this._connectionState}.`);\r\n        this.transport = undefined;\r\n        // If we have a stopError, it takes precedence over the error from the transport\r\n        error = this._stopError || error;\r\n        this._stopError = undefined;\r\n        if (this._connectionState === \"Disconnected\" /* ConnectionState.Disconnected */) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`);\r\n            return;\r\n        }\r\n        if (this._connectionState === \"Connecting\" /* ConnectionState.Connecting */) {\r\n            this._logger.log(LogLevel.Warning, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is still in the connecting state.`);\r\n            throw new Error(`HttpConnection.stopConnection(${error}) was called while the connection is still in the connecting state.`);\r\n        }\r\n        if (this._connectionState === \"Disconnecting\" /* ConnectionState.Disconnecting */) {\r\n            // A call to stop() induced this call to stopConnection and needs to be completed.\r\n            // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\r\n            this._stopPromiseResolver();\r\n        }\r\n        if (error) {\r\n            this._logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);\r\n        }\r\n        else {\r\n            this._logger.log(LogLevel.Information, \"Connection disconnected.\");\r\n        }\r\n        if (this._sendQueue) {\r\n            this._sendQueue.stop().catch((e) => {\r\n                this._logger.log(LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`);\r\n            });\r\n            this._sendQueue = undefined;\r\n        }\r\n        this.connectionId = undefined;\r\n        this._connectionState = \"Disconnected\" /* ConnectionState.Disconnected */;\r\n        if (this._connectionStarted) {\r\n            this._connectionStarted = false;\r\n            try {\r\n                if (this.onclose) {\r\n                    this.onclose(error);\r\n                }\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `HttpConnection.onclose(${error}) threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n    _resolveUrl(url) {\r\n        // startsWith is not supported in IE\r\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\r\n            return url;\r\n        }\r\n        if (!Platform.isBrowser) {\r\n            throw new Error(`Cannot resolve '${url}'.`);\r\n        }\r\n        // Setting the url to the href propery of an anchor tag handles normalization\r\n        // for us. There are 3 main cases.\r\n        // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\r\n        // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\r\n        // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\r\n        const aTag = window.document.createElement(\"a\");\r\n        aTag.href = url;\r\n        this._logger.log(LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);\r\n        return aTag.href;\r\n    }\r\n    _resolveNegotiateUrl(url) {\r\n        const negotiateUrl = new URL(url);\r\n        if (negotiateUrl.pathname.endsWith('/')) {\r\n            negotiateUrl.pathname += \"negotiate\";\r\n        }\r\n        else {\r\n            negotiateUrl.pathname += \"/negotiate\";\r\n        }\r\n        const searchParams = new URLSearchParams(negotiateUrl.searchParams);\r\n        if (!searchParams.has(\"negotiateVersion\")) {\r\n            searchParams.append(\"negotiateVersion\", this._negotiateVersion.toString());\r\n        }\r\n        if (searchParams.has(\"useStatefulReconnect\")) {\r\n            if (searchParams.get(\"useStatefulReconnect\") === \"true\") {\r\n                this._options._useStatefulReconnect = true;\r\n            }\r\n        }\r\n        else if (this._options._useStatefulReconnect === true) {\r\n            searchParams.append(\"useStatefulReconnect\", \"true\");\r\n        }\r\n        negotiateUrl.search = searchParams.toString();\r\n        return negotiateUrl.toString();\r\n    }\r\n}\r\nfunction transportMatches(requestedTransport, actualTransport) {\r\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\r\n}\r\n/** @private */\r\nexport class TransportSendQueue {\r\n    constructor(_transport) {\r\n        this._transport = _transport;\r\n        this._buffer = [];\r\n        this._executing = true;\r\n        this._sendBufferedData = new PromiseSource();\r\n        this._transportResult = new PromiseSource();\r\n        this._sendLoopPromise = this._sendLoop();\r\n    }\r\n    send(data) {\r\n        this._bufferData(data);\r\n        if (!this._transportResult) {\r\n            this._transportResult = new PromiseSource();\r\n        }\r\n        return this._transportResult.promise;\r\n    }\r\n    stop() {\r\n        this._executing = false;\r\n        this._sendBufferedData.resolve();\r\n        return this._sendLoopPromise;\r\n    }\r\n    _bufferData(data) {\r\n        if (this._buffer.length && typeof (this._buffer[0]) !== typeof (data)) {\r\n            throw new Error(`Expected data to be of type ${typeof (this._buffer)} but was of type ${typeof (data)}`);\r\n        }\r\n        this._buffer.push(data);\r\n        this._sendBufferedData.resolve();\r\n    }\r\n    async _sendLoop() {\r\n        while (true) {\r\n            await this._sendBufferedData.promise;\r\n            if (!this._executing) {\r\n                if (this._transportResult) {\r\n                    this._transportResult.reject(\"Connection stopped.\");\r\n                }\r\n                break;\r\n            }\r\n            this._sendBufferedData = new PromiseSource();\r\n            const transportResult = this._transportResult;\r\n            this._transportResult = undefined;\r\n            const data = typeof (this._buffer[0]) === \"string\" ?\r\n                this._buffer.join(\"\") :\r\n                TransportSendQueue._concatBuffers(this._buffer);\r\n            this._buffer.length = 0;\r\n            try {\r\n                await this._transport.send(data);\r\n                transportResult.resolve();\r\n            }\r\n            catch (error) {\r\n                transportResult.reject(error);\r\n            }\r\n        }\r\n    }\r\n    static _concatBuffers(arrayBuffers) {\r\n        const totalLength = arrayBuffers.map((b) => b.byteLength).reduce((a, b) => a + b);\r\n        const result = new Uint8Array(totalLength);\r\n        let offset = 0;\r\n        for (const item of arrayBuffers) {\r\n            result.set(new Uint8Array(item), offset);\r\n            offset += item.byteLength;\r\n        }\r\n        return result.buffer;\r\n    }\r\n}\r\nclass PromiseSource {\r\n    constructor() {\r\n        this.promise = new Promise((resolve, reject) => [this._resolver, this._rejecter] = [resolve, reject]);\r\n    }\r\n    resolve() {\r\n        this._resolver();\r\n    }\r\n    reject(reason) {\r\n        this._rejecter(reason);\r\n    }\r\n}\r\n//# sourceMappingURL=HttpConnection.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { HandshakeProtocol } from \"./HandshakeProtocol\";\r\nimport { AbortError } from \"./Errors\";\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { Subject } from \"./Subject\";\r\nimport { Arg, getErrorString, Platform } from \"./Utils\";\r\nimport { MessageBuffer } from \"./MessageBuffer\";\r\nconst DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\r\nconst DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;\r\nconst DEFAULT_STATEFUL_RECONNECT_BUFFER_SIZE = 100000;\r\n/** Describes the current state of the {@link HubConnection} to the server. */\r\nexport var HubConnectionState;\r\n(function (HubConnectionState) {\r\n    /** The hub connection is disconnected. */\r\n    HubConnectionState[\"Disconnected\"] = \"Disconnected\";\r\n    /** The hub connection is connecting. */\r\n    HubConnectionState[\"Connecting\"] = \"Connecting\";\r\n    /** The hub connection is connected. */\r\n    HubConnectionState[\"Connected\"] = \"Connected\";\r\n    /** The hub connection is disconnecting. */\r\n    HubConnectionState[\"Disconnecting\"] = \"Disconnecting\";\r\n    /** The hub connection is reconnecting. */\r\n    HubConnectionState[\"Reconnecting\"] = \"Reconnecting\";\r\n})(HubConnectionState || (HubConnectionState = {}));\r\n/** Represents a connection to a SignalR Hub. */\r\nexport class HubConnection {\r\n    /** @internal */\r\n    // Using a public static factory method means we can have a private constructor and an _internal_\r\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\r\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\r\n    // public parameter-less constructor.\r\n    static create(connection, logger, protocol, reconnectPolicy, serverTimeoutInMilliseconds, keepAliveIntervalInMilliseconds, statefulReconnectBufferSize) {\r\n        return new HubConnection(connection, logger, protocol, reconnectPolicy, serverTimeoutInMilliseconds, keepAliveIntervalInMilliseconds, statefulReconnectBufferSize);\r\n    }\r\n    constructor(connection, logger, protocol, reconnectPolicy, serverTimeoutInMilliseconds, keepAliveIntervalInMilliseconds, statefulReconnectBufferSize) {\r\n        this._nextKeepAlive = 0;\r\n        this._freezeEventListener = () => {\r\n            this._logger.log(LogLevel.Warning, \"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep\");\r\n        };\r\n        Arg.isRequired(connection, \"connection\");\r\n        Arg.isRequired(logger, \"logger\");\r\n        Arg.isRequired(protocol, \"protocol\");\r\n        this.serverTimeoutInMilliseconds = serverTimeoutInMilliseconds !== null && serverTimeoutInMilliseconds !== void 0 ? serverTimeoutInMilliseconds : DEFAULT_TIMEOUT_IN_MS;\r\n        this.keepAliveIntervalInMilliseconds = keepAliveIntervalInMilliseconds !== null && keepAliveIntervalInMilliseconds !== void 0 ? keepAliveIntervalInMilliseconds : DEFAULT_PING_INTERVAL_IN_MS;\r\n        this._statefulReconnectBufferSize = statefulReconnectBufferSize !== null && statefulReconnectBufferSize !== void 0 ? statefulReconnectBufferSize : DEFAULT_STATEFUL_RECONNECT_BUFFER_SIZE;\r\n        this._logger = logger;\r\n        this._protocol = protocol;\r\n        this.connection = connection;\r\n        this._reconnectPolicy = reconnectPolicy;\r\n        this._handshakeProtocol = new HandshakeProtocol();\r\n        this.connection.onreceive = (data) => this._processIncomingData(data);\r\n        this.connection.onclose = (error) => this._connectionClosed(error);\r\n        this._callbacks = {};\r\n        this._methods = {};\r\n        this._closedCallbacks = [];\r\n        this._reconnectingCallbacks = [];\r\n        this._reconnectedCallbacks = [];\r\n        this._invocationId = 0;\r\n        this._receivedHandshakeResponse = false;\r\n        this._connectionState = HubConnectionState.Disconnected;\r\n        this._connectionStarted = false;\r\n        this._cachedPingMessage = this._protocol.writeMessage({ type: MessageType.Ping });\r\n    }\r\n    /** Indicates the state of the {@link HubConnection} to the server. */\r\n    get state() {\r\n        return this._connectionState;\r\n    }\r\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n     *  in the disconnected state or if the negotiation step was skipped.\r\n     */\r\n    get connectionId() {\r\n        return this.connection ? (this.connection.connectionId || null) : null;\r\n    }\r\n    /** Indicates the url of the {@link HubConnection} to the server. */\r\n    get baseUrl() {\r\n        return this.connection.baseUrl || \"\";\r\n    }\r\n    /**\r\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n     * Reconnecting states.\r\n     * @param {string} url The url to connect to.\r\n     */\r\n    set baseUrl(url) {\r\n        if (this._connectionState !== HubConnectionState.Disconnected && this._connectionState !== HubConnectionState.Reconnecting) {\r\n            throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\r\n        }\r\n        if (!url) {\r\n            throw new Error(\"The HubConnection url must be a valid url.\");\r\n        }\r\n        this.connection.baseUrl = url;\r\n    }\r\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\r\n    start() {\r\n        this._startPromise = this._startWithStateTransitions();\r\n        return this._startPromise;\r\n    }\r\n    async _startWithStateTransitions() {\r\n        if (this._connectionState !== HubConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n        this._connectionState = HubConnectionState.Connecting;\r\n        this._logger.log(LogLevel.Debug, \"Starting HubConnection.\");\r\n        try {\r\n            await this._startInternal();\r\n            if (Platform.isBrowser) {\r\n                // Log when the browser freezes the tab so users know why their connection unexpectedly stopped working\r\n                window.document.addEventListener(\"freeze\", this._freezeEventListener);\r\n            }\r\n            this._connectionState = HubConnectionState.Connected;\r\n            this._connectionStarted = true;\r\n            this._logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\r\n        }\r\n        catch (e) {\r\n            this._connectionState = HubConnectionState.Disconnected;\r\n            this._logger.log(LogLevel.Debug, `HubConnection failed to start successfully because of error '${e}'.`);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n    async _startInternal() {\r\n        this._stopDuringStartError = undefined;\r\n        this._receivedHandshakeResponse = false;\r\n        // Set up the promise before any connection is (re)started otherwise it could race with received messages\r\n        const handshakePromise = new Promise((resolve, reject) => {\r\n            this._handshakeResolver = resolve;\r\n            this._handshakeRejecter = reject;\r\n        });\r\n        await this.connection.start(this._protocol.transferFormat);\r\n        try {\r\n            let version = this._protocol.version;\r\n            if (!this.connection.features.reconnect) {\r\n                // Stateful Reconnect starts with HubProtocol version 2, newer clients connecting to older servers will fail to connect due to\r\n                // the handshake only supporting version 1, so we will try to send version 1 during the handshake to keep old servers working.\r\n                version = 1;\r\n            }\r\n            const handshakeRequest = {\r\n                protocol: this._protocol.name,\r\n                version,\r\n            };\r\n            this._logger.log(LogLevel.Debug, \"Sending handshake request.\");\r\n            await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(handshakeRequest));\r\n            this._logger.log(LogLevel.Information, `Using HubProtocol '${this._protocol.name}'.`);\r\n            // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n            this._cleanupTimeout();\r\n            this._resetTimeoutPeriod();\r\n            this._resetKeepAliveInterval();\r\n            await handshakePromise;\r\n            // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\r\n            // being rejected on close, because this continuation can run after both the handshake completed successfully\r\n            // and the connection was closed.\r\n            if (this._stopDuringStartError) {\r\n                // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\r\n                // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\r\n                // will cause the calling continuation to get scheduled to run later.\r\n                // eslint-disable-next-line @typescript-eslint/no-throw-literal\r\n                throw this._stopDuringStartError;\r\n            }\r\n            const useStatefulReconnect = this.connection.features.reconnect || false;\r\n            if (useStatefulReconnect) {\r\n                this._messageBuffer = new MessageBuffer(this._protocol, this.connection, this._statefulReconnectBufferSize);\r\n                this.connection.features.disconnected = this._messageBuffer._disconnected.bind(this._messageBuffer);\r\n                this.connection.features.resend = () => {\r\n                    if (this._messageBuffer) {\r\n                        return this._messageBuffer._resend();\r\n                    }\r\n                };\r\n            }\r\n            if (!this.connection.features.inherentKeepAlive) {\r\n                await this._sendMessage(this._cachedPingMessage);\r\n            }\r\n        }\r\n        catch (e) {\r\n            this._logger.log(LogLevel.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`);\r\n            this._cleanupTimeout();\r\n            this._cleanupPingTimer();\r\n            // HttpConnection.stop() should not complete until after the onclose callback is invoked.\r\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\r\n            await this.connection.stop(e);\r\n            throw e;\r\n        }\r\n    }\r\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\r\n    async stop() {\r\n        // Capture the start promise before the connection might be restarted in an onclose callback.\r\n        const startPromise = this._startPromise;\r\n        this.connection.features.reconnect = false;\r\n        this._stopPromise = this._stopInternal();\r\n        await this._stopPromise;\r\n        try {\r\n            // Awaiting undefined continues immediately\r\n            await startPromise;\r\n        }\r\n        catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n    }\r\n    _stopInternal(error) {\r\n        if (this._connectionState === HubConnectionState.Disconnected) {\r\n            this._logger.log(LogLevel.Debug, `Call to HubConnection.stop(${error}) ignored because it is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n        if (this._connectionState === HubConnectionState.Disconnecting) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this._stopPromise;\r\n        }\r\n        const state = this._connectionState;\r\n        this._connectionState = HubConnectionState.Disconnecting;\r\n        this._logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\r\n        if (this._reconnectDelayHandle) {\r\n            // We're in a reconnect delay which means the underlying connection is currently already stopped.\r\n            // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\r\n            // fire the onclose callbacks.\r\n            this._logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\r\n            clearTimeout(this._reconnectDelayHandle);\r\n            this._reconnectDelayHandle = undefined;\r\n            this._completeClose();\r\n            return Promise.resolve();\r\n        }\r\n        if (state === HubConnectionState.Connected) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._sendCloseMessage();\r\n        }\r\n        this._cleanupTimeout();\r\n        this._cleanupPingTimer();\r\n        this._stopDuringStartError = error || new AbortError(\"The connection was stopped before the hub handshake could complete.\");\r\n        // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\r\n        // or the onclose callback is invoked. The onclose callback will transition the HubConnection\r\n        // to the disconnected state if need be before HttpConnection.stop() completes.\r\n        return this.connection.stop(error);\r\n    }\r\n    async _sendCloseMessage() {\r\n        try {\r\n            await this._sendWithProtocol(this._createCloseMessage());\r\n        }\r\n        catch {\r\n            // Ignore, this is a best effort attempt to let the server know the client closed gracefully.\r\n        }\r\n    }\r\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\r\n    stream(methodName, ...args) {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const invocationDescriptor = this._createStreamInvocation(methodName, args, streamIds);\r\n        // eslint-disable-next-line prefer-const\r\n        let promiseQueue;\r\n        const subject = new Subject();\r\n        subject.cancelCallback = () => {\r\n            const cancelInvocation = this._createCancelInvocation(invocationDescriptor.invocationId);\r\n            delete this._callbacks[invocationDescriptor.invocationId];\r\n            return promiseQueue.then(() => {\r\n                return this._sendWithProtocol(cancelInvocation);\r\n            });\r\n        };\r\n        this._callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            }\r\n            else if (invocationEvent) {\r\n                // invocationEvent will not be null when an error is not passed to the callback\r\n                if (invocationEvent.type === MessageType.Completion) {\r\n                    if (invocationEvent.error) {\r\n                        subject.error(new Error(invocationEvent.error));\r\n                    }\r\n                    else {\r\n                        subject.complete();\r\n                    }\r\n                }\r\n                else {\r\n                    subject.next((invocationEvent.item));\r\n                }\r\n            }\r\n        };\r\n        promiseQueue = this._sendWithProtocol(invocationDescriptor)\r\n            .catch((e) => {\r\n            subject.error(e);\r\n            delete this._callbacks[invocationDescriptor.invocationId];\r\n        });\r\n        this._launchStreams(streams, promiseQueue);\r\n        return subject;\r\n    }\r\n    _sendMessage(message) {\r\n        this._resetKeepAliveInterval();\r\n        return this.connection.send(message);\r\n    }\r\n    /**\r\n     * Sends a js object to the server.\r\n     * @param message The js object to serialize and send.\r\n     */\r\n    _sendWithProtocol(message) {\r\n        if (this._messageBuffer) {\r\n            return this._messageBuffer._send(message);\r\n        }\r\n        else {\r\n            return this._sendMessage(this._protocol.writeMessage(message));\r\n        }\r\n    }\r\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\r\n    send(methodName, ...args) {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const sendPromise = this._sendWithProtocol(this._createInvocation(methodName, args, true, streamIds));\r\n        this._launchStreams(streams, sendPromise);\r\n        return sendPromise;\r\n    }\r\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\r\n    invoke(methodName, ...args) {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const invocationDescriptor = this._createInvocation(methodName, args, false, streamIds);\r\n        const p = new Promise((resolve, reject) => {\r\n            // invocationId will always have a value for a non-blocking invocation\r\n            this._callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                }\r\n                else if (invocationEvent) {\r\n                    // invocationEvent will not be null when an error is not passed to the callback\r\n                    if (invocationEvent.type === MessageType.Completion) {\r\n                        if (invocationEvent.error) {\r\n                            reject(new Error(invocationEvent.error));\r\n                        }\r\n                        else {\r\n                            resolve(invocationEvent.result);\r\n                        }\r\n                    }\r\n                    else {\r\n                        reject(new Error(`Unexpected message type: ${invocationEvent.type}`));\r\n                    }\r\n                }\r\n            };\r\n            const promiseQueue = this._sendWithProtocol(invocationDescriptor)\r\n                .catch((e) => {\r\n                reject(e);\r\n                // invocationId will always have a value for a non-blocking invocation\r\n                delete this._callbacks[invocationDescriptor.invocationId];\r\n            });\r\n            this._launchStreams(streams, promiseQueue);\r\n        });\r\n        return p;\r\n    }\r\n    on(methodName, newMethod) {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        if (!this._methods[methodName]) {\r\n            this._methods[methodName] = [];\r\n        }\r\n        // Preventing adding the same handler multiple times.\r\n        if (this._methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n        this._methods[methodName].push(newMethod);\r\n    }\r\n    off(methodName, method) {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        const handlers = this._methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            const removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this._methods[methodName];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            delete this._methods[methodName];\r\n        }\r\n    }\r\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\r\n    onclose(callback) {\r\n        if (callback) {\r\n            this._closedCallbacks.push(callback);\r\n        }\r\n    }\r\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n     */\r\n    onreconnecting(callback) {\r\n        if (callback) {\r\n            this._reconnectingCallbacks.push(callback);\r\n        }\r\n    }\r\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n     */\r\n    onreconnected(callback) {\r\n        if (callback) {\r\n            this._reconnectedCallbacks.push(callback);\r\n        }\r\n    }\r\n    _processIncomingData(data) {\r\n        this._cleanupTimeout();\r\n        if (!this._receivedHandshakeResponse) {\r\n            data = this._processHandshakeResponse(data);\r\n            this._receivedHandshakeResponse = true;\r\n        }\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            const messages = this._protocol.parseMessages(data, this._logger);\r\n            for (const message of messages) {\r\n                if (this._messageBuffer && !this._messageBuffer._shouldProcessMessage(message)) {\r\n                    // Don't process the message, we are either waiting for a SequenceMessage or received a duplicate message\r\n                    continue;\r\n                }\r\n                switch (message.type) {\r\n                    case MessageType.Invocation:\r\n                        this._invokeClientMethod(message)\r\n                            .catch((e) => {\r\n                            this._logger.log(LogLevel.Error, `Invoke client method threw error: ${getErrorString(e)}`);\r\n                        });\r\n                        break;\r\n                    case MessageType.StreamItem:\r\n                    case MessageType.Completion: {\r\n                        const callback = this._callbacks[message.invocationId];\r\n                        if (callback) {\r\n                            if (message.type === MessageType.Completion) {\r\n                                delete this._callbacks[message.invocationId];\r\n                            }\r\n                            try {\r\n                                callback(message);\r\n                            }\r\n                            catch (e) {\r\n                                this._logger.log(LogLevel.Error, `Stream callback threw error: ${getErrorString(e)}`);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MessageType.Ping:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case MessageType.Close: {\r\n                        this._logger.log(LogLevel.Information, \"Close message received from server.\");\r\n                        const error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\r\n                        if (message.allowReconnect === true) {\r\n                            // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\r\n                            // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\r\n                            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n                            this.connection.stop(error);\r\n                        }\r\n                        else {\r\n                            // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\r\n                            this._stopPromise = this._stopInternal(error);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MessageType.Ack:\r\n                        if (this._messageBuffer) {\r\n                            this._messageBuffer._ack(message);\r\n                        }\r\n                        break;\r\n                    case MessageType.Sequence:\r\n                        if (this._messageBuffer) {\r\n                            this._messageBuffer._resetSequence(message);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        this._logger.log(LogLevel.Warning, `Invalid message type: ${message.type}.`);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        this._resetTimeoutPeriod();\r\n    }\r\n    _processHandshakeResponse(data) {\r\n        let responseMessage;\r\n        let remainingData;\r\n        try {\r\n            [remainingData, responseMessage] = this._handshakeProtocol.parseHandshakeResponse(data);\r\n        }\r\n        catch (e) {\r\n            const message = \"Error parsing handshake response: \" + e;\r\n            this._logger.log(LogLevel.Error, message);\r\n            const error = new Error(message);\r\n            this._handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            const message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this._logger.log(LogLevel.Error, message);\r\n            const error = new Error(message);\r\n            this._handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        else {\r\n            this._logger.log(LogLevel.Debug, \"Server handshake complete.\");\r\n        }\r\n        this._handshakeResolver();\r\n        return remainingData;\r\n    }\r\n    _resetKeepAliveInterval() {\r\n        if (this.connection.features.inherentKeepAlive) {\r\n            return;\r\n        }\r\n        // Set the time we want the next keep alive to be sent\r\n        // Timer will be setup on next message receive\r\n        this._nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;\r\n        this._cleanupPingTimer();\r\n    }\r\n    _resetTimeoutPeriod() {\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this._timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);\r\n            // Set keepAlive timer if there isn't one\r\n            if (this._pingServerHandle === undefined) {\r\n                let nextPing = this._nextKeepAlive - new Date().getTime();\r\n                if (nextPing < 0) {\r\n                    nextPing = 0;\r\n                }\r\n                // The timer needs to be set from a networking callback to avoid Chrome timer throttling from causing timers to run once a minute\r\n                this._pingServerHandle = setTimeout(async () => {\r\n                    if (this._connectionState === HubConnectionState.Connected) {\r\n                        try {\r\n                            await this._sendMessage(this._cachedPingMessage);\r\n                        }\r\n                        catch {\r\n                            // We don't care about the error. It should be seen elsewhere in the client.\r\n                            // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\r\n                            this._cleanupPingTimer();\r\n                        }\r\n                    }\r\n                }, nextPing);\r\n            }\r\n        }\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    serverTimeout() {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    }\r\n    async _invokeClientMethod(invocationMessage) {\r\n        const methodName = invocationMessage.target.toLowerCase();\r\n        const methods = this._methods[methodName];\r\n        if (!methods) {\r\n            this._logger.log(LogLevel.Warning, `No client method with the name '${methodName}' found.`);\r\n            // No handlers provided by client but the server is expecting a response still, so we send an error\r\n            if (invocationMessage.invocationId) {\r\n                this._logger.log(LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);\r\n                await this._sendWithProtocol(this._createCompletionMessage(invocationMessage.invocationId, \"Client didn't provide a result.\", null));\r\n            }\r\n            return;\r\n        }\r\n        // Avoid issues with handlers removing themselves thus modifying the list while iterating through it\r\n        const methodsCopy = methods.slice();\r\n        // Server expects a response\r\n        const expectsResponse = invocationMessage.invocationId ? true : false;\r\n        // We preserve the last result or exception but still call all handlers\r\n        let res;\r\n        let exception;\r\n        let completionMessage;\r\n        for (const m of methodsCopy) {\r\n            try {\r\n                const prevRes = res;\r\n                res = await m.apply(this, invocationMessage.arguments);\r\n                if (expectsResponse && res && prevRes) {\r\n                    this._logger.log(LogLevel.Error, `Multiple results provided for '${methodName}'. Sending error to server.`);\r\n                    completionMessage = this._createCompletionMessage(invocationMessage.invocationId, `Client provided multiple results.`, null);\r\n                }\r\n                // Ignore exception if we got a result after, the exception will be logged\r\n                exception = undefined;\r\n            }\r\n            catch (e) {\r\n                exception = e;\r\n                this._logger.log(LogLevel.Error, `A callback for the method '${methodName}' threw error '${e}'.`);\r\n            }\r\n        }\r\n        if (completionMessage) {\r\n            await this._sendWithProtocol(completionMessage);\r\n        }\r\n        else if (expectsResponse) {\r\n            // If there is an exception that means either no result was given or a handler after a result threw\r\n            if (exception) {\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId, `${exception}`, null);\r\n            }\r\n            else if (res !== undefined) {\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId, null, res);\r\n            }\r\n            else {\r\n                this._logger.log(LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);\r\n                // Client didn't provide a result or throw from a handler, server expects a response so we send an error\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId, \"Client didn't provide a result.\", null);\r\n            }\r\n            await this._sendWithProtocol(completionMessage);\r\n        }\r\n        else {\r\n            if (res) {\r\n                this._logger.log(LogLevel.Error, `Result given for '${methodName}' method but server is not expecting a result.`);\r\n            }\r\n        }\r\n    }\r\n    _connectionClosed(error) {\r\n        this._logger.log(LogLevel.Debug, `HubConnection.connectionClosed(${error}) called while in state ${this._connectionState}.`);\r\n        // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\r\n        this._stopDuringStartError = this._stopDuringStartError || error || new AbortError(\"The underlying connection was closed before the hub handshake could complete.\");\r\n        // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\r\n        // If it has already completed, this should just noop.\r\n        if (this._handshakeResolver) {\r\n            this._handshakeResolver();\r\n        }\r\n        this._cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\r\n        this._cleanupTimeout();\r\n        this._cleanupPingTimer();\r\n        if (this._connectionState === HubConnectionState.Disconnecting) {\r\n            this._completeClose(error);\r\n        }\r\n        else if (this._connectionState === HubConnectionState.Connected && this._reconnectPolicy) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._reconnect(error);\r\n        }\r\n        else if (this._connectionState === HubConnectionState.Connected) {\r\n            this._completeClose(error);\r\n        }\r\n        // If none of the above if conditions were true were called the HubConnection must be in either:\r\n        // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\r\n        // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\r\n        //    and potentially continue the reconnect() loop.\r\n        // 3. The Disconnected state in which case we're already done.\r\n    }\r\n    _completeClose(error) {\r\n        if (this._connectionStarted) {\r\n            this._connectionState = HubConnectionState.Disconnected;\r\n            this._connectionStarted = false;\r\n            if (this._messageBuffer) {\r\n                this._messageBuffer._dispose(error !== null && error !== void 0 ? error : new Error(\"Connection closed.\"));\r\n                this._messageBuffer = undefined;\r\n            }\r\n            if (Platform.isBrowser) {\r\n                window.document.removeEventListener(\"freeze\", this._freezeEventListener);\r\n            }\r\n            try {\r\n                this._closedCallbacks.forEach((c) => c.apply(this, [error]));\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `An onclose callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n    async _reconnect(error) {\r\n        const reconnectStartTime = Date.now();\r\n        let previousReconnectAttempts = 0;\r\n        let retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\r\n        let nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\r\n        if (nextRetryDelay === null) {\r\n            this._logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\r\n            this._completeClose(error);\r\n            return;\r\n        }\r\n        this._connectionState = HubConnectionState.Reconnecting;\r\n        if (error) {\r\n            this._logger.log(LogLevel.Information, `Connection reconnecting because of error '${error}'.`);\r\n        }\r\n        else {\r\n            this._logger.log(LogLevel.Information, \"Connection reconnecting.\");\r\n        }\r\n        if (this._reconnectingCallbacks.length !== 0) {\r\n            try {\r\n                this._reconnectingCallbacks.forEach((c) => c.apply(this, [error]));\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `An onreconnecting callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n            // Exit early if an onreconnecting callback called connection.stop().\r\n            if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\r\n                return;\r\n            }\r\n        }\r\n        while (nextRetryDelay !== null) {\r\n            this._logger.log(LogLevel.Information, `Reconnect attempt number ${previousReconnectAttempts} will start in ${nextRetryDelay} ms.`);\r\n            await new Promise((resolve) => {\r\n                this._reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);\r\n            });\r\n            this._reconnectDelayHandle = undefined;\r\n            if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\r\n                return;\r\n            }\r\n            try {\r\n                await this._startInternal();\r\n                this._connectionState = HubConnectionState.Connected;\r\n                this._logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\r\n                if (this._reconnectedCallbacks.length !== 0) {\r\n                    try {\r\n                        this._reconnectedCallbacks.forEach((c) => c.apply(this, [this.connection.connectionId]));\r\n                    }\r\n                    catch (e) {\r\n                        this._logger.log(LogLevel.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`);\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Information, `Reconnect attempt failed because of error '${e}'.`);\r\n                if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                    this._logger.log(LogLevel.Debug, `Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`);\r\n                    // The TypeScript compiler thinks that connectionState must be Connected here. The TypeScript compiler is wrong.\r\n                    if (this._connectionState === HubConnectionState.Disconnecting) {\r\n                        this._completeClose();\r\n                    }\r\n                    return;\r\n                }\r\n                retryError = e instanceof Error ? e : new Error(e.toString());\r\n                nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\r\n            }\r\n        }\r\n        this._logger.log(LogLevel.Information, `Reconnect retries have been exhausted after ${Date.now() - reconnectStartTime} ms and ${previousReconnectAttempts} failed attempts. Connection disconnecting.`);\r\n        this._completeClose();\r\n    }\r\n    _getNextRetryDelay(previousRetryCount, elapsedMilliseconds, retryReason) {\r\n        try {\r\n            return this._reconnectPolicy.nextRetryDelayInMilliseconds({\r\n                elapsedMilliseconds,\r\n                previousRetryCount,\r\n                retryReason,\r\n            });\r\n        }\r\n        catch (e) {\r\n            this._logger.log(LogLevel.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${previousRetryCount}, ${elapsedMilliseconds}) threw error '${e}'.`);\r\n            return null;\r\n        }\r\n    }\r\n    _cancelCallbacksWithError(error) {\r\n        const callbacks = this._callbacks;\r\n        this._callbacks = {};\r\n        Object.keys(callbacks)\r\n            .forEach((key) => {\r\n            const callback = callbacks[key];\r\n            try {\r\n                callback(null, error);\r\n            }\r\n            catch (e) {\r\n                this._logger.log(LogLevel.Error, `Stream 'error' callback called with '${error}' threw error: ${getErrorString(e)}`);\r\n            }\r\n        });\r\n    }\r\n    _cleanupPingTimer() {\r\n        if (this._pingServerHandle) {\r\n            clearTimeout(this._pingServerHandle);\r\n            this._pingServerHandle = undefined;\r\n        }\r\n    }\r\n    _cleanupTimeout() {\r\n        if (this._timeoutHandle) {\r\n            clearTimeout(this._timeoutHandle);\r\n        }\r\n    }\r\n    _createInvocation(methodName, args, nonblocking, streamIds) {\r\n        if (nonblocking) {\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    arguments: args,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        }\r\n        else {\r\n            const invocationId = this._invocationId;\r\n            this._invocationId++;\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        }\r\n    }\r\n    _launchStreams(streams, promiseQueue) {\r\n        if (streams.length === 0) {\r\n            return;\r\n        }\r\n        // Synchronize stream data so they arrive in-order on the server\r\n        if (!promiseQueue) {\r\n            promiseQueue = Promise.resolve();\r\n        }\r\n        // We want to iterate over the keys, since the keys are the stream ids\r\n        // eslint-disable-next-line guard-for-in\r\n        for (const streamId in streams) {\r\n            streams[streamId].subscribe({\r\n                complete: () => {\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId)));\r\n                },\r\n                error: (err) => {\r\n                    let message;\r\n                    if (err instanceof Error) {\r\n                        message = err.message;\r\n                    }\r\n                    else if (err && err.toString) {\r\n                        message = err.toString();\r\n                    }\r\n                    else {\r\n                        message = \"Unknown error\";\r\n                    }\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId, message)));\r\n                },\r\n                next: (item) => {\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createStreamItemMessage(streamId, item)));\r\n                },\r\n            });\r\n        }\r\n    }\r\n    _replaceStreamingParams(args) {\r\n        const streams = [];\r\n        const streamIds = [];\r\n        for (let i = 0; i < args.length; i++) {\r\n            const argument = args[i];\r\n            if (this._isObservable(argument)) {\r\n                const streamId = this._invocationId;\r\n                this._invocationId++;\r\n                // Store the stream for later use\r\n                streams[streamId] = argument;\r\n                streamIds.push(streamId.toString());\r\n                // remove stream from args\r\n                args.splice(i, 1);\r\n            }\r\n        }\r\n        return [streams, streamIds];\r\n    }\r\n    _isObservable(arg) {\r\n        // This allows other stream implementations to just work (like rxjs)\r\n        return arg && arg.subscribe && typeof arg.subscribe === \"function\";\r\n    }\r\n    _createStreamInvocation(methodName, args, streamIds) {\r\n        const invocationId = this._invocationId;\r\n        this._invocationId++;\r\n        if (streamIds.length !== 0) {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                streamIds,\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        }\r\n    }\r\n    _createCancelInvocation(id) {\r\n        return {\r\n            invocationId: id,\r\n            type: MessageType.CancelInvocation,\r\n        };\r\n    }\r\n    _createStreamItemMessage(id, item) {\r\n        return {\r\n            invocationId: id,\r\n            item,\r\n            type: MessageType.StreamItem,\r\n        };\r\n    }\r\n    _createCompletionMessage(id, error, result) {\r\n        if (error) {\r\n            return {\r\n                error,\r\n                invocationId: id,\r\n                type: MessageType.Completion,\r\n            };\r\n        }\r\n        return {\r\n            invocationId: id,\r\n            result,\r\n            type: MessageType.Completion,\r\n        };\r\n    }\r\n    _createCloseMessage() {\r\n        return { type: MessageType.Close };\r\n    }\r\n}\r\n//# sourceMappingURL=HubConnection.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { DefaultReconnectPolicy } from \"./DefaultReconnectPolicy\";\r\nimport { HttpConnection } from \"./HttpConnection\";\r\nimport { HubConnection } from \"./HubConnection\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { JsonHubProtocol } from \"./JsonHubProtocol\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { Arg, ConsoleLogger } from \"./Utils\";\r\nconst LogLevelNameMapping = {\r\n    trace: LogLevel.Trace,\r\n    debug: LogLevel.Debug,\r\n    info: LogLevel.Information,\r\n    information: LogLevel.Information,\r\n    warn: LogLevel.Warning,\r\n    warning: LogLevel.Warning,\r\n    error: LogLevel.Error,\r\n    critical: LogLevel.Critical,\r\n    none: LogLevel.None,\r\n};\r\nfunction parseLogLevel(name) {\r\n    // Case-insensitive matching via lower-casing\r\n    // Yes, I know case-folding is a complicated problem in Unicode, but we only support\r\n    // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.\r\n    const mapping = LogLevelNameMapping[name.toLowerCase()];\r\n    if (typeof mapping !== \"undefined\") {\r\n        return mapping;\r\n    }\r\n    else {\r\n        throw new Error(`Unknown log level: ${name}`);\r\n    }\r\n}\r\n/** A builder for configuring {@link @microsoft/signalr.HubConnection} instances. */\r\nexport class HubConnectionBuilder {\r\n    configureLogging(logging) {\r\n        Arg.isRequired(logging, \"logging\");\r\n        if (isLogger(logging)) {\r\n            this.logger = logging;\r\n        }\r\n        else if (typeof logging === \"string\") {\r\n            const logLevel = parseLogLevel(logging);\r\n            this.logger = new ConsoleLogger(logLevel);\r\n        }\r\n        else {\r\n            this.logger = new ConsoleLogger(logging);\r\n        }\r\n        return this;\r\n    }\r\n    withUrl(url, transportTypeOrOptions) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isNotEmpty(url, \"url\");\r\n        this.url = url;\r\n        // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed\r\n        // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.\r\n        if (typeof transportTypeOrOptions === \"object\") {\r\n            this.httpConnectionOptions = { ...this.httpConnectionOptions, ...transportTypeOrOptions };\r\n        }\r\n        else {\r\n            this.httpConnectionOptions = {\r\n                ...this.httpConnectionOptions,\r\n                transport: transportTypeOrOptions,\r\n            };\r\n        }\r\n        return this;\r\n    }\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.\r\n     *\r\n     * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.\r\n     */\r\n    withHubProtocol(protocol) {\r\n        Arg.isRequired(protocol, \"protocol\");\r\n        this.protocol = protocol;\r\n        return this;\r\n    }\r\n    withAutomaticReconnect(retryDelaysOrReconnectPolicy) {\r\n        if (this.reconnectPolicy) {\r\n            throw new Error(\"A reconnectPolicy has already been set.\");\r\n        }\r\n        if (!retryDelaysOrReconnectPolicy) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy();\r\n        }\r\n        else if (Array.isArray(retryDelaysOrReconnectPolicy)) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);\r\n        }\r\n        else {\r\n            this.reconnectPolicy = retryDelaysOrReconnectPolicy;\r\n        }\r\n        return this;\r\n    }\r\n    /** Configures {@link @microsoft/signalr.HubConnection.serverTimeoutInMilliseconds} for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    withServerTimeout(milliseconds) {\r\n        Arg.isRequired(milliseconds, \"milliseconds\");\r\n        this._serverTimeoutInMilliseconds = milliseconds;\r\n        return this;\r\n    }\r\n    /** Configures {@link @microsoft/signalr.HubConnection.keepAliveIntervalInMilliseconds} for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    withKeepAliveInterval(milliseconds) {\r\n        Arg.isRequired(milliseconds, \"milliseconds\");\r\n        this._keepAliveIntervalInMilliseconds = milliseconds;\r\n        return this;\r\n    }\r\n    /** Enables and configures options for the Stateful Reconnect feature.\r\n     *\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    withStatefulReconnect(options) {\r\n        if (this.httpConnectionOptions === undefined) {\r\n            this.httpConnectionOptions = {};\r\n        }\r\n        this.httpConnectionOptions._useStatefulReconnect = true;\r\n        this._statefulReconnectBufferSize = options === null || options === void 0 ? void 0 : options.bufferSize;\r\n        return this;\r\n    }\r\n    /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.\r\n     *\r\n     * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.\r\n     */\r\n    build() {\r\n        // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one\r\n        // provided to configureLogger\r\n        const httpConnectionOptions = this.httpConnectionOptions || {};\r\n        // If it's 'null', the user **explicitly** asked for null, don't mess with it.\r\n        if (httpConnectionOptions.logger === undefined) {\r\n            // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.\r\n            httpConnectionOptions.logger = this.logger;\r\n        }\r\n        // Now create the connection\r\n        if (!this.url) {\r\n            throw new Error(\"The 'HubConnectionBuilder.withUrl' method must be called before building the connection.\");\r\n        }\r\n        const connection = new HttpConnection(this.url, httpConnectionOptions);\r\n        return HubConnection.create(connection, this.logger || NullLogger.instance, this.protocol || new JsonHubProtocol(), this.reconnectPolicy, this._serverTimeoutInMilliseconds, this._keepAliveIntervalInMilliseconds, this._statefulReconnectBufferSize);\r\n    }\r\n}\r\nfunction isLogger(logger) {\r\n    return logger.log !== undefined;\r\n}\r\n//# sourceMappingURL=HubConnectionBuilder.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n/** Defines the type of a Hub Message. */\r\nexport var MessageType;\r\n(function (MessageType) {\r\n    /** Indicates the message is an Invocation message and implements the {@link @microsoft/signalr.InvocationMessage} interface. */\r\n    MessageType[MessageType[\"Invocation\"] = 1] = \"Invocation\";\r\n    /** Indicates the message is a StreamItem message and implements the {@link @microsoft/signalr.StreamItemMessage} interface. */\r\n    MessageType[MessageType[\"StreamItem\"] = 2] = \"StreamItem\";\r\n    /** Indicates the message is a Completion message and implements the {@link @microsoft/signalr.CompletionMessage} interface. */\r\n    MessageType[MessageType[\"Completion\"] = 3] = \"Completion\";\r\n    /** Indicates the message is a Stream Invocation message and implements the {@link @microsoft/signalr.StreamInvocationMessage} interface. */\r\n    MessageType[MessageType[\"StreamInvocation\"] = 4] = \"StreamInvocation\";\r\n    /** Indicates the message is a Cancel Invocation message and implements the {@link @microsoft/signalr.CancelInvocationMessage} interface. */\r\n    MessageType[MessageType[\"CancelInvocation\"] = 5] = \"CancelInvocation\";\r\n    /** Indicates the message is a Ping message and implements the {@link @microsoft/signalr.PingMessage} interface. */\r\n    MessageType[MessageType[\"Ping\"] = 6] = \"Ping\";\r\n    /** Indicates the message is a Close message and implements the {@link @microsoft/signalr.CloseMessage} interface. */\r\n    MessageType[MessageType[\"Close\"] = 7] = \"Close\";\r\n    MessageType[MessageType[\"Ack\"] = 8] = \"Ack\";\r\n    MessageType[MessageType[\"Sequence\"] = 9] = \"Sequence\";\r\n})(MessageType || (MessageType = {}));\r\n//# sourceMappingURL=IHubProtocol.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.\r\n/** Indicates the severity of a log message.\r\n *\r\n * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.\r\n */\r\nexport var LogLevel;\r\n(function (LogLevel) {\r\n    /** Log level for very low severity diagnostic messages. */\r\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\r\n    /** Log level for low severity diagnostic messages. */\r\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\r\n    /** Log level for informational diagnostic messages. */\r\n    LogLevel[LogLevel[\"Information\"] = 2] = \"Information\";\r\n    /** Log level for diagnostic messages that indicate a non-fatal problem. */\r\n    LogLevel[LogLevel[\"Warning\"] = 3] = \"Warning\";\r\n    /** Log level for diagnostic messages that indicate a failure in the current operation. */\r\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\r\n    /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */\r\n    LogLevel[LogLevel[\"Critical\"] = 5] = \"Critical\";\r\n    /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */\r\n    LogLevel[LogLevel[\"None\"] = 6] = \"None\";\r\n})(LogLevel || (LogLevel = {}));\r\n//# sourceMappingURL=ILogger.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// This will be treated as a bit flag in the future, so we keep it using power-of-two values.\r\n/** Specifies a specific HTTP transport type. */\r\nexport var HttpTransportType;\r\n(function (HttpTransportType) {\r\n    /** Specifies no transport preference. */\r\n    HttpTransportType[HttpTransportType[\"None\"] = 0] = \"None\";\r\n    /** Specifies the WebSockets transport. */\r\n    HttpTransportType[HttpTransportType[\"WebSockets\"] = 1] = \"WebSockets\";\r\n    /** Specifies the Server-Sent Events transport. */\r\n    HttpTransportType[HttpTransportType[\"ServerSentEvents\"] = 2] = \"ServerSentEvents\";\r\n    /** Specifies the Long Polling transport. */\r\n    HttpTransportType[HttpTransportType[\"LongPolling\"] = 4] = \"LongPolling\";\r\n})(HttpTransportType || (HttpTransportType = {}));\r\n/** Specifies the transfer format for a connection. */\r\nexport var TransferFormat;\r\n(function (TransferFormat) {\r\n    /** Specifies that only text data will be transmitted over the connection. */\r\n    TransferFormat[TransferFormat[\"Text\"] = 1] = \"Text\";\r\n    /** Specifies that binary data will be transmitted over the connection. */\r\n    TransferFormat[TransferFormat[\"Binary\"] = 2] = \"Binary\";\r\n})(TransferFormat || (TransferFormat = {}));\r\n//# sourceMappingURL=ITransport.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\nconst JSON_HUB_PROTOCOL_NAME = \"json\";\r\n/** Implements the JSON Hub Protocol. */\r\nexport class JsonHubProtocol {\r\n    constructor() {\r\n        /** @inheritDoc */\r\n        this.name = JSON_HUB_PROTOCOL_NAME;\r\n        /** @inheritDoc */\r\n        this.version = 2;\r\n        /** @inheritDoc */\r\n        this.transferFormat = TransferFormat.Text;\r\n    }\r\n    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n     *\r\n     * @param {string} input A string containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    parseMessages(input, logger) {\r\n        // The interface does allow \"ArrayBuffer\" to be passed in, but this implementation does not. So let's throw a useful error.\r\n        if (typeof input !== \"string\") {\r\n            throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\r\n        }\r\n        if (!input) {\r\n            return [];\r\n        }\r\n        if (logger === null) {\r\n            logger = NullLogger.instance;\r\n        }\r\n        // Parse the messages\r\n        const messages = TextMessageFormat.parse(input);\r\n        const hubMessages = [];\r\n        for (const message of messages) {\r\n            const parsedMessage = JSON.parse(message);\r\n            if (typeof parsedMessage.type !== \"number\") {\r\n                throw new Error(\"Invalid payload.\");\r\n            }\r\n            switch (parsedMessage.type) {\r\n                case MessageType.Invocation:\r\n                    this._isInvocationMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.StreamItem:\r\n                    this._isStreamItemMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Completion:\r\n                    this._isCompletionMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Ping:\r\n                    // Single value, no need to validate\r\n                    break;\r\n                case MessageType.Close:\r\n                    // All optional values, no need to validate\r\n                    break;\r\n                case MessageType.Ack:\r\n                    this._isAckMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Sequence:\r\n                    this._isSequenceMessage(parsedMessage);\r\n                    break;\r\n                default:\r\n                    // Future protocol changes can add message types, old clients can ignore them\r\n                    logger.log(LogLevel.Information, \"Unknown message type '\" + parsedMessage.type + \"' ignored.\");\r\n                    continue;\r\n            }\r\n            hubMessages.push(parsedMessage);\r\n        }\r\n        return hubMessages;\r\n    }\r\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string} A string containing the serialized representation of the message.\r\n     */\r\n    writeMessage(message) {\r\n        return TextMessageFormat.write(JSON.stringify(message));\r\n    }\r\n    _isInvocationMessage(message) {\r\n        this._assertNotEmptyString(message.target, \"Invalid payload for Invocation message.\");\r\n        if (message.invocationId !== undefined) {\r\n            this._assertNotEmptyString(message.invocationId, \"Invalid payload for Invocation message.\");\r\n        }\r\n    }\r\n    _isStreamItemMessage(message) {\r\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for StreamItem message.\");\r\n        if (message.item === undefined) {\r\n            throw new Error(\"Invalid payload for StreamItem message.\");\r\n        }\r\n    }\r\n    _isCompletionMessage(message) {\r\n        if (message.result && message.error) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n        if (!message.result && message.error) {\r\n            this._assertNotEmptyString(message.error, \"Invalid payload for Completion message.\");\r\n        }\r\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for Completion message.\");\r\n    }\r\n    _isAckMessage(message) {\r\n        if (typeof message.sequenceId !== 'number') {\r\n            throw new Error(\"Invalid SequenceId for Ack message.\");\r\n        }\r\n    }\r\n    _isSequenceMessage(message) {\r\n        if (typeof message.sequenceId !== 'number') {\r\n            throw new Error(\"Invalid SequenceId for Sequence message.\");\r\n        }\r\n    }\r\n    _assertNotEmptyString(value, errorMessage) {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            throw new Error(errorMessage);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=JsonHubProtocol.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n/** A logger that does nothing when log messages are sent to it. */\r\nexport class NullLogger {\r\n    constructor() { }\r\n    /** @inheritDoc */\r\n    // eslint-disable-next-line\r\n    log(_logLevel, _message) {\r\n    }\r\n}\r\n/** The singleton instance of the {@link @microsoft/signalr.NullLogger}. */\r\nNullLogger.instance = new NullLogger();\r\n//# sourceMappingURL=Loggers.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AbortController } from \"./AbortController\";\r\nimport { HttpError, TimeoutError } from \"./Errors\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, sendMessage } from \"./Utils\";\r\n// Not exported from 'index', this type is internal.\r\n/** @private */\r\nexport class LongPollingTransport {\r\n    // This is an internal type, not exported from 'index' so this is really just internal.\r\n    get pollAborted() {\r\n        return this._pollAbort.aborted;\r\n    }\r\n    constructor(httpClient, logger, options) {\r\n        this._httpClient = httpClient;\r\n        this._logger = logger;\r\n        this._pollAbort = new AbortController();\r\n        this._options = options;\r\n        this._running = false;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    async connect(url, transferFormat) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._url = url;\r\n        this._logger.log(LogLevel.Trace, \"(LongPolling transport) Connecting.\");\r\n        // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)\r\n        if (transferFormat === TransferFormat.Binary &&\r\n            (typeof XMLHttpRequest !== \"undefined\" && typeof new XMLHttpRequest().responseType !== \"string\")) {\r\n            throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\r\n        }\r\n        const [name, value] = getUserAgentHeader();\r\n        const headers = { [name]: value, ...this._options.headers };\r\n        const pollOptions = {\r\n            abortSignal: this._pollAbort.signal,\r\n            headers,\r\n            timeout: 100000,\r\n            withCredentials: this._options.withCredentials,\r\n        };\r\n        if (transferFormat === TransferFormat.Binary) {\r\n            pollOptions.responseType = \"arraybuffer\";\r\n        }\r\n        // Make initial long polling request\r\n        // Server uses first long polling request to finish initializing connection and it returns without data\r\n        const pollUrl = `${url}&_=${Date.now()}`;\r\n        this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n        const response = await this._httpClient.get(pollUrl, pollOptions);\r\n        if (response.statusCode !== 200) {\r\n            this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n            // Mark running as false so that the poll immediately ends and runs the close logic\r\n            this._closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n            this._running = false;\r\n        }\r\n        else {\r\n            this._running = true;\r\n        }\r\n        this._receiving = this._poll(this._url, pollOptions);\r\n    }\r\n    async _poll(url, pollOptions) {\r\n        try {\r\n            while (this._running) {\r\n                try {\r\n                    const pollUrl = `${url}&_=${Date.now()}`;\r\n                    this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n                    const response = await this._httpClient.get(pollUrl, pollOptions);\r\n                    if (response.statusCode === 204) {\r\n                        this._logger.log(LogLevel.Information, \"(LongPolling transport) Poll terminated by server.\");\r\n                        this._running = false;\r\n                    }\r\n                    else if (response.statusCode !== 200) {\r\n                        this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n                        // Unexpected status code\r\n                        this._closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n                        this._running = false;\r\n                    }\r\n                    else {\r\n                        // Process the response\r\n                        if (response.content) {\r\n                            this._logger.log(LogLevel.Trace, `(LongPolling transport) data received. ${getDataDetail(response.content, this._options.logMessageContent)}.`);\r\n                            if (this.onreceive) {\r\n                                this.onreceive(response.content);\r\n                            }\r\n                        }\r\n                        else {\r\n                            // This is another way timeout manifest.\r\n                            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    if (!this._running) {\r\n                        // Log but disregard errors that occur after stopping\r\n                        this._logger.log(LogLevel.Trace, `(LongPolling transport) Poll errored after shutdown: ${e.message}`);\r\n                    }\r\n                    else {\r\n                        if (e instanceof TimeoutError) {\r\n                            // Ignore timeouts and reissue the poll.\r\n                            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        }\r\n                        else {\r\n                            // Close the connection with the error as the result.\r\n                            this._closeError = e;\r\n                            this._running = false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Polling complete.\");\r\n            // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.\r\n            // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.\r\n            if (!this.pollAborted) {\r\n                this._raiseOnClose();\r\n            }\r\n        }\r\n    }\r\n    async send(data) {\r\n        if (!this._running) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"LongPolling\", this._httpClient, this._url, data, this._options);\r\n    }\r\n    async stop() {\r\n        this._logger.log(LogLevel.Trace, \"(LongPolling transport) Stopping polling.\");\r\n        // Tell receiving loop to stop, abort any current request, and then wait for it to finish\r\n        this._running = false;\r\n        this._pollAbort.abort();\r\n        try {\r\n            await this._receiving;\r\n            // Send DELETE to clean up long polling on the server\r\n            this._logger.log(LogLevel.Trace, `(LongPolling transport) sending DELETE request to ${this._url}.`);\r\n            const headers = {};\r\n            const [name, value] = getUserAgentHeader();\r\n            headers[name] = value;\r\n            const deleteOptions = {\r\n                headers: { ...headers, ...this._options.headers },\r\n                timeout: this._options.timeout,\r\n                withCredentials: this._options.withCredentials,\r\n            };\r\n            let error;\r\n            try {\r\n                await this._httpClient.delete(this._url, deleteOptions);\r\n            }\r\n            catch (err) {\r\n                error = err;\r\n            }\r\n            if (error) {\r\n                if (error instanceof HttpError) {\r\n                    if (error.statusCode === 404) {\r\n                        this._logger.log(LogLevel.Trace, \"(LongPolling transport) A 404 response was returned from sending a DELETE request.\");\r\n                    }\r\n                    else {\r\n                        this._logger.log(LogLevel.Trace, `(LongPolling transport) Error sending a DELETE request: ${error}`);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                this._logger.log(LogLevel.Trace, \"(LongPolling transport) DELETE request accepted.\");\r\n            }\r\n        }\r\n        finally {\r\n            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Stop finished.\");\r\n            // Raise close event here instead of in polling\r\n            // It needs to happen after the DELETE request is sent\r\n            this._raiseOnClose();\r\n        }\r\n    }\r\n    _raiseOnClose() {\r\n        if (this.onclose) {\r\n            let logMessage = \"(LongPolling transport) Firing onclose event.\";\r\n            if (this._closeError) {\r\n                logMessage += \" Error: \" + this._closeError;\r\n            }\r\n            this._logger.log(LogLevel.Trace, logMessage);\r\n            this.onclose(this._closeError);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=LongPollingTransport.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n/** @private */\r\nexport class MessageBuffer {\r\n    constructor(protocol, connection, bufferSize) {\r\n        this._bufferSize = 100000;\r\n        this._messages = [];\r\n        this._totalMessageCount = 0;\r\n        this._waitForSequenceMessage = false;\r\n        // Message IDs start at 1 and always increment by 1\r\n        this._nextReceivingSequenceId = 1;\r\n        this._latestReceivedSequenceId = 0;\r\n        this._bufferedByteCount = 0;\r\n        this._reconnectInProgress = false;\r\n        this._protocol = protocol;\r\n        this._connection = connection;\r\n        this._bufferSize = bufferSize;\r\n    }\r\n    async _send(message) {\r\n        const serializedMessage = this._protocol.writeMessage(message);\r\n        let backpressurePromise = Promise.resolve();\r\n        // Only count invocation messages. Acks, pings, etc. don't need to be resent on reconnect\r\n        if (this._isInvocationMessage(message)) {\r\n            this._totalMessageCount++;\r\n            let backpressurePromiseResolver = () => { };\r\n            let backpressurePromiseRejector = () => { };\r\n            if (isArrayBuffer(serializedMessage)) {\r\n                this._bufferedByteCount += serializedMessage.byteLength;\r\n            }\r\n            else {\r\n                this._bufferedByteCount += serializedMessage.length;\r\n            }\r\n            if (this._bufferedByteCount >= this._bufferSize) {\r\n                backpressurePromise = new Promise((resolve, reject) => {\r\n                    backpressurePromiseResolver = resolve;\r\n                    backpressurePromiseRejector = reject;\r\n                });\r\n            }\r\n            this._messages.push(new BufferedItem(serializedMessage, this._totalMessageCount, backpressurePromiseResolver, backpressurePromiseRejector));\r\n        }\r\n        try {\r\n            // If this is set it means we are reconnecting or resending\r\n            // We don't want to send on a disconnected connection\r\n            // And we don't want to send if resend is running since that would mean sending\r\n            // this message twice\r\n            if (!this._reconnectInProgress) {\r\n                await this._connection.send(serializedMessage);\r\n            }\r\n        }\r\n        catch {\r\n            this._disconnected();\r\n        }\r\n        await backpressurePromise;\r\n    }\r\n    _ack(ackMessage) {\r\n        let newestAckedMessage = -1;\r\n        // Find index of newest message being acked\r\n        for (let index = 0; index < this._messages.length; index++) {\r\n            const element = this._messages[index];\r\n            if (element._id <= ackMessage.sequenceId) {\r\n                newestAckedMessage = index;\r\n                if (isArrayBuffer(element._message)) {\r\n                    this._bufferedByteCount -= element._message.byteLength;\r\n                }\r\n                else {\r\n                    this._bufferedByteCount -= element._message.length;\r\n                }\r\n                // resolve items that have already been sent and acked\r\n                element._resolver();\r\n            }\r\n            else if (this._bufferedByteCount < this._bufferSize) {\r\n                // resolve items that now fall under the buffer limit but haven't been acked\r\n                element._resolver();\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        if (newestAckedMessage !== -1) {\r\n            // We're removing everything including the message pointed to, so add 1\r\n            this._messages = this._messages.slice(newestAckedMessage + 1);\r\n        }\r\n    }\r\n    _shouldProcessMessage(message) {\r\n        if (this._waitForSequenceMessage) {\r\n            if (message.type !== MessageType.Sequence) {\r\n                return false;\r\n            }\r\n            else {\r\n                this._waitForSequenceMessage = false;\r\n                return true;\r\n            }\r\n        }\r\n        // No special processing for acks, pings, etc.\r\n        if (!this._isInvocationMessage(message)) {\r\n            return true;\r\n        }\r\n        const currentId = this._nextReceivingSequenceId;\r\n        this._nextReceivingSequenceId++;\r\n        if (currentId <= this._latestReceivedSequenceId) {\r\n            if (currentId === this._latestReceivedSequenceId) {\r\n                // Should only hit this if we just reconnected and the server is sending\r\n                // Messages it has buffered, which would mean it hasn't seen an Ack for these messages\r\n                this._ackTimer();\r\n            }\r\n            // Ignore, this is a duplicate message\r\n            return false;\r\n        }\r\n        this._latestReceivedSequenceId = currentId;\r\n        // Only start the timer for sending an Ack message when we have a message to ack. This also conveniently solves\r\n        // timer throttling by not having a recursive timer, and by starting the timer via a network call (recv)\r\n        this._ackTimer();\r\n        return true;\r\n    }\r\n    _resetSequence(message) {\r\n        if (message.sequenceId > this._nextReceivingSequenceId) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._connection.stop(new Error(\"Sequence ID greater than amount of messages we've received.\"));\r\n            return;\r\n        }\r\n        this._nextReceivingSequenceId = message.sequenceId;\r\n    }\r\n    _disconnected() {\r\n        this._reconnectInProgress = true;\r\n        this._waitForSequenceMessage = true;\r\n    }\r\n    async _resend() {\r\n        const sequenceId = this._messages.length !== 0\r\n            ? this._messages[0]._id\r\n            : this._totalMessageCount + 1;\r\n        await this._connection.send(this._protocol.writeMessage({ type: MessageType.Sequence, sequenceId }));\r\n        // Get a local variable to the _messages, just in case messages are acked while resending\r\n        // Which would slice the _messages array (which creates a new copy)\r\n        const messages = this._messages;\r\n        for (const element of messages) {\r\n            await this._connection.send(element._message);\r\n        }\r\n        this._reconnectInProgress = false;\r\n    }\r\n    _dispose(error) {\r\n        error !== null && error !== void 0 ? error : (error = new Error(\"Unable to reconnect to server.\"));\r\n        // Unblock backpressure if any\r\n        for (const element of this._messages) {\r\n            element._rejector(error);\r\n        }\r\n    }\r\n    _isInvocationMessage(message) {\r\n        // There is no way to check if something implements an interface.\r\n        // So we individually check the messages in a switch statement.\r\n        // To make sure we don't miss any message types we rely on the compiler\r\n        // seeing the function returns a value and it will do the\r\n        // exhaustive check for us on the switch statement, since we don't use 'case default'\r\n        switch (message.type) {\r\n            case MessageType.Invocation:\r\n            case MessageType.StreamItem:\r\n            case MessageType.Completion:\r\n            case MessageType.StreamInvocation:\r\n            case MessageType.CancelInvocation:\r\n                return true;\r\n            case MessageType.Close:\r\n            case MessageType.Sequence:\r\n            case MessageType.Ping:\r\n            case MessageType.Ack:\r\n                return false;\r\n        }\r\n    }\r\n    _ackTimer() {\r\n        if (this._ackTimerHandle === undefined) {\r\n            this._ackTimerHandle = setTimeout(async () => {\r\n                try {\r\n                    if (!this._reconnectInProgress) {\r\n                        await this._connection.send(this._protocol.writeMessage({ type: MessageType.Ack, sequenceId: this._latestReceivedSequenceId }));\r\n                    }\r\n                    // Ignore errors, that means the connection is closed and we don't care about the Ack message anymore.\r\n                }\r\n                catch { }\r\n                clearTimeout(this._ackTimerHandle);\r\n                this._ackTimerHandle = undefined;\r\n                // 1 second delay so we don't spam Ack messages if there are many messages being received at once.\r\n            }, 1000);\r\n        }\r\n    }\r\n}\r\nclass BufferedItem {\r\n    constructor(message, id, resolver, rejector) {\r\n        this._message = message;\r\n        this._id = id;\r\n        this._resolver = resolver;\r\n        this._rejector = rejector;\r\n    }\r\n}\r\n//# sourceMappingURL=MessageBuffer.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\r\n/** @private */\r\nexport class ServerSentEventsTransport {\r\n    constructor(httpClient, accessToken, logger, options) {\r\n        this._httpClient = httpClient;\r\n        this._accessToken = accessToken;\r\n        this._logger = logger;\r\n        this._options = options;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    async connect(url, transferFormat) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n        // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\r\n        this._url = url;\r\n        if (this._accessToken) {\r\n            url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(this._accessToken)}`;\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            let opened = false;\r\n            if (transferFormat !== TransferFormat.Text) {\r\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n                return;\r\n            }\r\n            let eventSource;\r\n            if (Platform.isBrowser || Platform.isWebWorker) {\r\n                eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials });\r\n            }\r\n            else {\r\n                // Non-browser passes cookies via the dictionary\r\n                const cookies = this._httpClient.getCookieString(url);\r\n                const headers = {};\r\n                headers.Cookie = cookies;\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n                eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials, headers: { ...headers, ...this._options.headers } });\r\n            }\r\n            try {\r\n                eventSource.onmessage = (e) => {\r\n                    if (this.onreceive) {\r\n                        try {\r\n                            this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent)}.`);\r\n                            this.onreceive(e.data);\r\n                        }\r\n                        catch (error) {\r\n                            this._close(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                };\r\n                // @ts-ignore: not using event on purpose\r\n                eventSource.onerror = (e) => {\r\n                    // EventSource doesn't give any useful information about server side closes.\r\n                    if (opened) {\r\n                        this._close();\r\n                    }\r\n                    else {\r\n                        reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\"\r\n                            + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\"\r\n                            + \" If you have multiple servers check that sticky sessions are enabled.\"));\r\n                    }\r\n                };\r\n                eventSource.onopen = () => {\r\n                    this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`);\r\n                    this._eventSource = eventSource;\r\n                    opened = true;\r\n                    resolve();\r\n                };\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n    async send(data) {\r\n        if (!this._eventSource) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"SSE\", this._httpClient, this._url, data, this._options);\r\n    }\r\n    stop() {\r\n        this._close();\r\n        return Promise.resolve();\r\n    }\r\n    _close(e) {\r\n        if (this._eventSource) {\r\n            this._eventSource.close();\r\n            this._eventSource = undefined;\r\n            if (this.onclose) {\r\n                this.onclose(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=ServerSentEventsTransport.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { SubjectSubscription } from \"./Utils\";\r\n/** Stream implementation to stream items to the server. */\r\nexport class Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n    next(item) {\r\n        for (const observer of this.observers) {\r\n            observer.next(item);\r\n        }\r\n    }\r\n    error(err) {\r\n        for (const observer of this.observers) {\r\n            if (observer.error) {\r\n                observer.error(err);\r\n            }\r\n        }\r\n    }\r\n    complete() {\r\n        for (const observer of this.observers) {\r\n            if (observer.complete) {\r\n                observer.complete();\r\n            }\r\n        }\r\n    }\r\n    subscribe(observer) {\r\n        this.observers.push(observer);\r\n        return new SubjectSubscription(this, observer);\r\n    }\r\n}\r\n//# sourceMappingURL=Subject.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// Not exported from index\r\n/** @private */\r\nexport class TextMessageFormat {\r\n    static write(output) {\r\n        return `${output}${TextMessageFormat.RecordSeparator}`;\r\n    }\r\n    static parse(input) {\r\n        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\r\n            throw new Error(\"Message is incomplete.\");\r\n        }\r\n        const messages = input.split(TextMessageFormat.RecordSeparator);\r\n        messages.pop();\r\n        return messages;\r\n    }\r\n}\r\nTextMessageFormat.RecordSeparatorCode = 0x1e;\r\nTextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\r\n//# sourceMappingURL=TextMessageFormat.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { NullLogger } from \"./Loggers\";\r\n// Version token that will be replaced by the prepack command\r\n/** The version of the SignalR client. */\r\nexport const VERSION = \"8.0.7\";\r\n/** @private */\r\nexport class Arg {\r\n    static isRequired(val, name) {\r\n        if (val === null || val === undefined) {\r\n            throw new Error(`The '${name}' argument is required.`);\r\n        }\r\n    }\r\n    static isNotEmpty(val, name) {\r\n        if (!val || val.match(/^\\s*$/)) {\r\n            throw new Error(`The '${name}' argument should not be empty.`);\r\n        }\r\n    }\r\n    static isIn(val, values, name) {\r\n        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\r\n        if (!(val in values)) {\r\n            throw new Error(`Unknown ${name} value: ${val}.`);\r\n        }\r\n    }\r\n}\r\n/** @private */\r\nexport class Platform {\r\n    // react-native has a window but no document so we should check both\r\n    static get isBrowser() {\r\n        return !Platform.isNode && typeof window === \"object\" && typeof window.document === \"object\";\r\n    }\r\n    // WebWorkers don't have a window object so the isBrowser check would fail\r\n    static get isWebWorker() {\r\n        return !Platform.isNode && typeof self === \"object\" && \"importScripts\" in self;\r\n    }\r\n    // react-native has a window but no document\r\n    static get isReactNative() {\r\n        return !Platform.isNode && typeof window === \"object\" && typeof window.document === \"undefined\";\r\n    }\r\n    // Node apps shouldn't have a window object, but WebWorkers don't either\r\n    // so we need to check for both WebWorker and window\r\n    static get isNode() {\r\n        return typeof process !== \"undefined\" && process.release && process.release.name === \"node\";\r\n    }\r\n}\r\n/** @private */\r\nexport function getDataDetail(data, includeContent) {\r\n    let detail = \"\";\r\n    if (isArrayBuffer(data)) {\r\n        detail = `Binary data of length ${data.byteLength}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${formatArrayBuffer(data)}'`;\r\n        }\r\n    }\r\n    else if (typeof data === \"string\") {\r\n        detail = `String data of length ${data.length}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${data}'`;\r\n        }\r\n    }\r\n    return detail;\r\n}\r\n/** @private */\r\nexport function formatArrayBuffer(data) {\r\n    const view = new Uint8Array(data);\r\n    // Uint8Array.map only supports returning another Uint8Array?\r\n    let str = \"\";\r\n    view.forEach((num) => {\r\n        const pad = num < 16 ? \"0\" : \"\";\r\n        str += `0x${pad}${num.toString(16)} `;\r\n    });\r\n    // Trim of trailing space.\r\n    return str.substr(0, str.length - 1);\r\n}\r\n// Also in signalr-protocol-msgpack/Utils.ts\r\n/** @private */\r\nexport function isArrayBuffer(val) {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}\r\n/** @private */\r\nexport async function sendMessage(logger, transportName, httpClient, url, content, options) {\r\n    const headers = {};\r\n    const [name, value] = getUserAgentHeader();\r\n    headers[name] = value;\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) sending data. ${getDataDetail(content, options.logMessageContent)}.`);\r\n    const responseType = isArrayBuffer(content) ? \"arraybuffer\" : \"text\";\r\n    const response = await httpClient.post(url, {\r\n        content,\r\n        headers: { ...headers, ...options.headers },\r\n        responseType,\r\n        timeout: options.timeout,\r\n        withCredentials: options.withCredentials,\r\n    });\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) request complete. Response status: ${response.statusCode}.`);\r\n}\r\n/** @private */\r\nexport function createLogger(logger) {\r\n    if (logger === undefined) {\r\n        return new ConsoleLogger(LogLevel.Information);\r\n    }\r\n    if (logger === null) {\r\n        return NullLogger.instance;\r\n    }\r\n    if (logger.log !== undefined) {\r\n        return logger;\r\n    }\r\n    return new ConsoleLogger(logger);\r\n}\r\n/** @private */\r\nexport class SubjectSubscription {\r\n    constructor(subject, observer) {\r\n        this._subject = subject;\r\n        this._observer = observer;\r\n    }\r\n    dispose() {\r\n        const index = this._subject.observers.indexOf(this._observer);\r\n        if (index > -1) {\r\n            this._subject.observers.splice(index, 1);\r\n        }\r\n        if (this._subject.observers.length === 0 && this._subject.cancelCallback) {\r\n            this._subject.cancelCallback().catch((_) => { });\r\n        }\r\n    }\r\n}\r\n/** @private */\r\nexport class ConsoleLogger {\r\n    constructor(minimumLogLevel) {\r\n        this._minLevel = minimumLogLevel;\r\n        this.out = console;\r\n    }\r\n    log(logLevel, message) {\r\n        if (logLevel >= this._minLevel) {\r\n            const msg = `[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`;\r\n            switch (logLevel) {\r\n                case LogLevel.Critical:\r\n                case LogLevel.Error:\r\n                    this.out.error(msg);\r\n                    break;\r\n                case LogLevel.Warning:\r\n                    this.out.warn(msg);\r\n                    break;\r\n                case LogLevel.Information:\r\n                    this.out.info(msg);\r\n                    break;\r\n                default:\r\n                    // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\r\n                    this.out.log(msg);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n/** @private */\r\nexport function getUserAgentHeader() {\r\n    let userAgentHeaderName = \"X-SignalR-User-Agent\";\r\n    if (Platform.isNode) {\r\n        userAgentHeaderName = \"User-Agent\";\r\n    }\r\n    return [userAgentHeaderName, constructUserAgent(VERSION, getOsName(), getRuntime(), getRuntimeVersion())];\r\n}\r\n/** @private */\r\nexport function constructUserAgent(version, os, runtime, runtimeVersion) {\r\n    // Microsoft SignalR/[Version] ([Detailed Version]; [Operating System]; [Runtime]; [Runtime Version])\r\n    let userAgent = \"Microsoft SignalR/\";\r\n    const majorAndMinor = version.split(\".\");\r\n    userAgent += `${majorAndMinor[0]}.${majorAndMinor[1]}`;\r\n    userAgent += ` (${version}; `;\r\n    if (os && os !== \"\") {\r\n        userAgent += `${os}; `;\r\n    }\r\n    else {\r\n        userAgent += \"Unknown OS; \";\r\n    }\r\n    userAgent += `${runtime}`;\r\n    if (runtimeVersion) {\r\n        userAgent += `; ${runtimeVersion}`;\r\n    }\r\n    else {\r\n        userAgent += \"; Unknown Runtime Version\";\r\n    }\r\n    userAgent += \")\";\r\n    return userAgent;\r\n}\r\n// eslint-disable-next-line spaced-comment\r\n/*#__PURE__*/ function getOsName() {\r\n    if (Platform.isNode) {\r\n        switch (process.platform) {\r\n            case \"win32\":\r\n                return \"Windows NT\";\r\n            case \"darwin\":\r\n                return \"macOS\";\r\n            case \"linux\":\r\n                return \"Linux\";\r\n            default:\r\n                return process.platform;\r\n        }\r\n    }\r\n    else {\r\n        return \"\";\r\n    }\r\n}\r\n// eslint-disable-next-line spaced-comment\r\n/*#__PURE__*/ function getRuntimeVersion() {\r\n    if (Platform.isNode) {\r\n        return process.versions.node;\r\n    }\r\n    return undefined;\r\n}\r\nfunction getRuntime() {\r\n    if (Platform.isNode) {\r\n        return \"NodeJS\";\r\n    }\r\n    else {\r\n        return \"Browser\";\r\n    }\r\n}\r\n/** @private */\r\nexport function getErrorString(e) {\r\n    if (e.stack) {\r\n        return e.stack;\r\n    }\r\n    else if (e.message) {\r\n        return e.message;\r\n    }\r\n    return `${e}`;\r\n}\r\n/** @private */\r\nexport function getGlobalThis() {\r\n    // globalThis is semi-new and not available in Node until v12\r\n    if (typeof globalThis !== \"undefined\") {\r\n        return globalThis;\r\n    }\r\n    if (typeof self !== \"undefined\") {\r\n        return self;\r\n    }\r\n    if (typeof window !== \"undefined\") {\r\n        return window;\r\n    }\r\n    if (typeof global !== \"undefined\") {\r\n        return global;\r\n    }\r\n    throw new Error(\"could not find global\");\r\n}\r\n//# sourceMappingURL=Utils.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform } from \"./Utils\";\r\n/** @private */\r\nexport class WebSocketTransport {\r\n    constructor(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor, headers) {\r\n        this._logger = logger;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n        this._logMessageContent = logMessageContent;\r\n        this._webSocketConstructor = webSocketConstructor;\r\n        this._httpClient = httpClient;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n        this._headers = headers;\r\n    }\r\n    async connect(url, transferFormat) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\r\n        let token;\r\n        if (this._accessTokenFactory) {\r\n            token = await this._accessTokenFactory();\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            url = url.replace(/^http/, \"ws\");\r\n            let webSocket;\r\n            const cookies = this._httpClient.getCookieString(url);\r\n            let opened = false;\r\n            if (Platform.isNode || Platform.isReactNative) {\r\n                const headers = {};\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n                if (token) {\r\n                    headers[HeaderNames.Authorization] = `Bearer ${token}`;\r\n                }\r\n                if (cookies) {\r\n                    headers[HeaderNames.Cookie] = cookies;\r\n                }\r\n                // Only pass headers when in non-browser environments\r\n                webSocket = new this._webSocketConstructor(url, undefined, {\r\n                    headers: { ...headers, ...this._headers },\r\n                });\r\n            }\r\n            else {\r\n                if (token) {\r\n                    url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n                }\r\n            }\r\n            if (!webSocket) {\r\n                // Chrome is not happy with passing 'undefined' as protocol\r\n                webSocket = new this._webSocketConstructor(url);\r\n            }\r\n            if (transferFormat === TransferFormat.Binary) {\r\n                webSocket.binaryType = \"arraybuffer\";\r\n            }\r\n            webSocket.onopen = (_event) => {\r\n                this._logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);\r\n                this._webSocket = webSocket;\r\n                opened = true;\r\n                resolve();\r\n            };\r\n            webSocket.onerror = (event) => {\r\n                let error = null;\r\n                // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                    error = event.error;\r\n                }\r\n                else {\r\n                    error = \"There was an error with the transport\";\r\n                }\r\n                this._logger.log(LogLevel.Information, `(WebSockets transport) ${error}.`);\r\n            };\r\n            webSocket.onmessage = (message) => {\r\n                this._logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this._logMessageContent)}.`);\r\n                if (this.onreceive) {\r\n                    try {\r\n                        this.onreceive(message.data);\r\n                    }\r\n                    catch (error) {\r\n                        this._close(error);\r\n                        return;\r\n                    }\r\n                }\r\n            };\r\n            webSocket.onclose = (event) => {\r\n                // Don't call close handler if connection was never established\r\n                // We'll reject the connect call instead\r\n                if (opened) {\r\n                    this._close(event);\r\n                }\r\n                else {\r\n                    let error = null;\r\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                    if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                        error = event.error;\r\n                    }\r\n                    else {\r\n                        error = \"WebSocket failed to connect. The connection could not be found on the server,\"\r\n                            + \" either the endpoint may not be a SignalR endpoint,\"\r\n                            + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\"\r\n                            + \" If you have multiple servers check that sticky sessions are enabled.\";\r\n                    }\r\n                    reject(new Error(error));\r\n                }\r\n            };\r\n        });\r\n    }\r\n    send(data) {\r\n        if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\r\n            this._logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this._logMessageContent)}.`);\r\n            this._webSocket.send(data);\r\n            return Promise.resolve();\r\n        }\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    }\r\n    stop() {\r\n        if (this._webSocket) {\r\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\r\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\r\n            this._close(undefined);\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    _close(event) {\r\n        // webSocket will be null if the transport did not start successfully\r\n        if (this._webSocket) {\r\n            // Clear websocket handlers because we are considering the socket closed now\r\n            this._webSocket.onclose = () => { };\r\n            this._webSocket.onmessage = () => { };\r\n            this._webSocket.onerror = () => { };\r\n            this._webSocket.close();\r\n            this._webSocket = undefined;\r\n        }\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\r\n        if (this.onclose) {\r\n            if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\r\n                this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason || \"no reason given\"}).`));\r\n            }\r\n            else if (event instanceof Error) {\r\n                this.onclose(event);\r\n            }\r\n            else {\r\n                this.onclose();\r\n            }\r\n        }\r\n    }\r\n    _isCloseEvent(event) {\r\n        return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\r\n    }\r\n}\r\n//# sourceMappingURL=WebSocketTransport.js.map","// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpResponse } from \"./HttpClient\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\nexport class XhrHttpClient extends HttpClient {\r\n    constructor(logger) {\r\n        super();\r\n        this._logger = logger;\r\n    }\r\n    /** @inheritDoc */\r\n    send(request) {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            const xhr = new XMLHttpRequest();\r\n            xhr.open(request.method, request.url, true);\r\n            xhr.withCredentials = request.withCredentials === undefined ? true : request.withCredentials;\r\n            xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\r\n            if (request.content === \"\") {\r\n                request.content = undefined;\r\n            }\r\n            if (request.content) {\r\n                // Explicitly setting the Content-Type header for React Native on Android platform.\r\n                if (isArrayBuffer(request.content)) {\r\n                    xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\r\n                }\r\n                else {\r\n                    xhr.setRequestHeader(\"Content-Type\", \"text/plain;charset=UTF-8\");\r\n                }\r\n            }\r\n            const headers = request.headers;\r\n            if (headers) {\r\n                Object.keys(headers)\r\n                    .forEach((header) => {\r\n                    xhr.setRequestHeader(header, headers[header]);\r\n                });\r\n            }\r\n            if (request.responseType) {\r\n                xhr.responseType = request.responseType;\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = () => {\r\n                    xhr.abort();\r\n                    reject(new AbortError());\r\n                };\r\n            }\r\n            if (request.timeout) {\r\n                xhr.timeout = request.timeout;\r\n            }\r\n            xhr.onload = () => {\r\n                if (request.abortSignal) {\r\n                    request.abortSignal.onabort = null;\r\n                }\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(new HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));\r\n                }\r\n                else {\r\n                    reject(new HttpError(xhr.response || xhr.responseText || xhr.statusText, xhr.status));\r\n                }\r\n            };\r\n            xhr.onerror = () => {\r\n                this._logger.log(LogLevel.Warning, `Error from HTTP request. ${xhr.status}: ${xhr.statusText}.`);\r\n                reject(new HttpError(xhr.statusText, xhr.status));\r\n            };\r\n            xhr.ontimeout = () => {\r\n                this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                reject(new TimeoutError());\r\n            };\r\n            xhr.send(request.content);\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=XhrHttpClient.js.map","import\"reflect-metadata\";export{LazyServiceIdentifier}from\"@inversifyjs/common\";export{Container,ContainerModule}from\"@inversifyjs/container\";export{bindingScopeValues,bindingTypeValues,decorate,inject,injectFromBase,injectable,multiInject,named,optional,postConstruct,preDestroy,tagged,unmanaged}from\"@inversifyjs/core\";\n//# sourceMappingURL=index.js.map\n","/*! *****************************************************************************\nCopyright (C) Microsoft. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar Reflect;\n(function (Reflect) {\n    // Metadata Proposal\n    // https://rbuckton.github.io/reflect-metadata/\n    (function (factory) {\n        var root = typeof globalThis === \"object\" ? globalThis :\n            typeof global === \"object\" ? global :\n                typeof self === \"object\" ? self :\n                    typeof this === \"object\" ? this :\n                        sloppyModeThis();\n        var exporter = makeExporter(Reflect);\n        if (typeof root.Reflect !== \"undefined\") {\n            exporter = makeExporter(root.Reflect, exporter);\n        }\n        factory(exporter, root);\n        if (typeof root.Reflect === \"undefined\") {\n            root.Reflect = Reflect;\n        }\n        function makeExporter(target, previous) {\n            return function (key, value) {\n                Object.defineProperty(target, key, { configurable: true, writable: true, value: value });\n                if (previous)\n                    previous(key, value);\n            };\n        }\n        function functionThis() {\n            try {\n                return Function(\"return this;\")();\n            }\n            catch (_) { }\n        }\n        function indirectEvalThis() {\n            try {\n                return (void 0, eval)(\"(function() { return this; })()\");\n            }\n            catch (_) { }\n        }\n        function sloppyModeThis() {\n            return functionThis() || indirectEvalThis();\n        }\n    })(function (exporter, root) {\n        var hasOwn = Object.prototype.hasOwnProperty;\n        // feature test for Symbol support\n        var supportsSymbol = typeof Symbol === \"function\";\n        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== \"undefined\" ? Symbol.toPrimitive : \"@@toPrimitive\";\n        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== \"undefined\" ? Symbol.iterator : \"@@iterator\";\n        var supportsCreate = typeof Object.create === \"function\"; // feature test for Object.create support\n        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support\n        var downLevel = !supportsCreate && !supportsProto;\n        var HashMap = {\n            // create an object in dictionary mode (a.k.a. \"slow\" mode in v8)\n            create: supportsCreate\n                ? function () { return MakeDictionary(Object.create(null)); }\n                : supportsProto\n                    ? function () { return MakeDictionary({ __proto__: null }); }\n                    : function () { return MakeDictionary({}); },\n            has: downLevel\n                ? function (map, key) { return hasOwn.call(map, key); }\n                : function (map, key) { return key in map; },\n            get: downLevel\n                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }\n                : function (map, key) { return map[key]; },\n        };\n        // Load global or shim versions of Map, Set, and WeakMap\n        var functionPrototype = Object.getPrototypeOf(Function);\n        var _Map = typeof Map === \"function\" && typeof Map.prototype.entries === \"function\" ? Map : CreateMapPolyfill();\n        var _Set = typeof Set === \"function\" && typeof Set.prototype.entries === \"function\" ? Set : CreateSetPolyfill();\n        var _WeakMap = typeof WeakMap === \"function\" ? WeakMap : CreateWeakMapPolyfill();\n        var registrySymbol = supportsSymbol ? Symbol.for(\"@reflect-metadata:registry\") : undefined;\n        var metadataRegistry = GetOrCreateMetadataRegistry();\n        var metadataProvider = CreateMetadataProvider(metadataRegistry);\n        /**\n         * Applies a set of decorators to a property of a target object.\n         * @param decorators An array of decorators.\n         * @param target The target object.\n         * @param propertyKey (Optional) The property key to decorate.\n         * @param attributes (Optional) The property descriptor for the target key.\n         * @remarks Decorators are applied in reverse order.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     Example = Reflect.decorate(decoratorsArray, Example);\n         *\n         *     // property (on constructor)\n         *     Reflect.decorate(decoratorsArray, Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     Reflect.decorate(decoratorsArray, Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     Object.defineProperty(Example, \"staticMethod\",\n         *         Reflect.decorate(decoratorsArray, Example, \"staticMethod\",\n         *             Object.getOwnPropertyDescriptor(Example, \"staticMethod\")));\n         *\n         *     // method (on prototype)\n         *     Object.defineProperty(Example.prototype, \"method\",\n         *         Reflect.decorate(decoratorsArray, Example.prototype, \"method\",\n         *             Object.getOwnPropertyDescriptor(Example.prototype, \"method\")));\n         *\n         */\n        function decorate(decorators, target, propertyKey, attributes) {\n            if (!IsUndefined(propertyKey)) {\n                if (!IsArray(decorators))\n                    throw new TypeError();\n                if (!IsObject(target))\n                    throw new TypeError();\n                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))\n                    throw new TypeError();\n                if (IsNull(attributes))\n                    attributes = undefined;\n                propertyKey = ToPropertyKey(propertyKey);\n                return DecorateProperty(decorators, target, propertyKey, attributes);\n            }\n            else {\n                if (!IsArray(decorators))\n                    throw new TypeError();\n                if (!IsConstructor(target))\n                    throw new TypeError();\n                return DecorateConstructor(decorators, target);\n            }\n        }\n        exporter(\"decorate\", decorate);\n        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)\n        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata\n        /**\n         * A default metadata decorator factory that can be used on a class, class member, or parameter.\n         * @param metadataKey The key for the metadata entry.\n         * @param metadataValue The value for the metadata entry.\n         * @returns A decorator function.\n         * @remarks\n         * If `metadataKey` is already defined for the target and target key, the\n         * metadataValue for that key will be overwritten.\n         * @example\n         *\n         *     // constructor\n         *     @Reflect.metadata(key, value)\n         *     class Example {\n         *     }\n         *\n         *     // property (on constructor, TypeScript only)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         static staticProperty;\n         *     }\n         *\n         *     // property (on prototype, TypeScript only)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         property;\n         *     }\n         *\n         *     // method (on constructor)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         static staticMethod() { }\n         *     }\n         *\n         *     // method (on prototype)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         method() { }\n         *     }\n         *\n         */\n        function metadata(metadataKey, metadataValue) {\n            function decorator(target, propertyKey) {\n                if (!IsObject(target))\n                    throw new TypeError();\n                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))\n                    throw new TypeError();\n                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\n            }\n            return decorator;\n        }\n        exporter(\"metadata\", metadata);\n        /**\n         * Define a unique metadata entry on the target.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param metadataValue A value that contains attached metadata.\n         * @param target The target object on which to define metadata.\n         * @param propertyKey (Optional) The property key for the target.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example);\n         *\n         *     // property (on constructor)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"method\");\n         *\n         *     // decorator factory as metadata-producing annotation.\n         *     function MyAnnotation(options): Decorator {\n         *         return (target, key?) => Reflect.defineMetadata(\"custom:annotation\", options, target, key);\n         *     }\n         *\n         */\n        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\n        }\n        exporter(\"defineMetadata\", defineMetadata);\n        /**\n         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function hasMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryHasMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"hasMetadata\", hasMetadata);\n        /**\n         * Gets a value indicating whether the target object has the provided metadata key defined.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function hasOwnMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"hasOwnMetadata\", hasOwnMetadata);\n        /**\n         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function getMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryGetMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"getMetadata\", getMetadata);\n        /**\n         * Gets the metadata value for the provided metadata key on the target object.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function getOwnMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"getOwnMetadata\", getOwnMetadata);\n        /**\n         * Gets the metadata keys defined on the target object or its prototype chain.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns An array of unique metadata keys.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getMetadataKeys(Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getMetadataKeys(Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getMetadataKeys(Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getMetadataKeys(Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getMetadataKeys(Example.prototype, \"method\");\n         *\n         */\n        function getMetadataKeys(target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryMetadataKeys(target, propertyKey);\n        }\n        exporter(\"getMetadataKeys\", getMetadataKeys);\n        /**\n         * Gets the unique metadata keys defined on the target object.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns An array of unique metadata keys.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getOwnMetadataKeys(Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getOwnMetadataKeys(Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getOwnMetadataKeys(Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"method\");\n         *\n         */\n        function getOwnMetadataKeys(target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryOwnMetadataKeys(target, propertyKey);\n        }\n        exporter(\"getOwnMetadataKeys\", getOwnMetadataKeys);\n        /**\n         * Deletes the metadata entry from the target object with the provided key.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata entry was found and deleted; otherwise, false.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */\n        function deleteMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            if (!IsObject(target))\n                throw new TypeError();\n            if (!IsUndefined(propertyKey))\n                propertyKey = ToPropertyKey(propertyKey);\n            var provider = GetMetadataProvider(target, propertyKey, /*Create*/ false);\n            if (IsUndefined(provider))\n                return false;\n            return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"deleteMetadata\", deleteMetadata);\n        function DecorateConstructor(decorators, target) {\n            for (var i = decorators.length - 1; i >= 0; --i) {\n                var decorator = decorators[i];\n                var decorated = decorator(target);\n                if (!IsUndefined(decorated) && !IsNull(decorated)) {\n                    if (!IsConstructor(decorated))\n                        throw new TypeError();\n                    target = decorated;\n                }\n            }\n            return target;\n        }\n        function DecorateProperty(decorators, target, propertyKey, descriptor) {\n            for (var i = decorators.length - 1; i >= 0; --i) {\n                var decorator = decorators[i];\n                var decorated = decorator(target, propertyKey, descriptor);\n                if (!IsUndefined(decorated) && !IsNull(decorated)) {\n                    if (!IsObject(decorated))\n                        throw new TypeError();\n                    descriptor = decorated;\n                }\n            }\n            return descriptor;\n        }\n        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata\n        function OrdinaryHasMetadata(MetadataKey, O, P) {\n            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\n            if (hasOwn)\n                return true;\n            var parent = OrdinaryGetPrototypeOf(O);\n            if (!IsNull(parent))\n                return OrdinaryHasMetadata(MetadataKey, parent, P);\n            return false;\n        }\n        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata\n        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {\n            var provider = GetMetadataProvider(O, P, /*Create*/ false);\n            if (IsUndefined(provider))\n                return false;\n            return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));\n        }\n        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata\n        function OrdinaryGetMetadata(MetadataKey, O, P) {\n            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\n            if (hasOwn)\n                return OrdinaryGetOwnMetadata(MetadataKey, O, P);\n            var parent = OrdinaryGetPrototypeOf(O);\n            if (!IsNull(parent))\n                return OrdinaryGetMetadata(MetadataKey, parent, P);\n            return undefined;\n        }\n        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata\n        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {\n            var provider = GetMetadataProvider(O, P, /*Create*/ false);\n            if (IsUndefined(provider))\n                return;\n            return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);\n        }\n        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata\n        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {\n            var provider = GetMetadataProvider(O, P, /*Create*/ true);\n            provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);\n        }\n        // 3.1.6.1 OrdinaryMetadataKeys(O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys\n        function OrdinaryMetadataKeys(O, P) {\n            var ownKeys = OrdinaryOwnMetadataKeys(O, P);\n            var parent = OrdinaryGetPrototypeOf(O);\n            if (parent === null)\n                return ownKeys;\n            var parentKeys = OrdinaryMetadataKeys(parent, P);\n            if (parentKeys.length <= 0)\n                return ownKeys;\n            if (ownKeys.length <= 0)\n                return parentKeys;\n            var set = new _Set();\n            var keys = [];\n            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {\n                var key = ownKeys_1[_i];\n                var hasKey = set.has(key);\n                if (!hasKey) {\n                    set.add(key);\n                    keys.push(key);\n                }\n            }\n            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {\n                var key = parentKeys_1[_a];\n                var hasKey = set.has(key);\n                if (!hasKey) {\n                    set.add(key);\n                    keys.push(key);\n                }\n            }\n            return keys;\n        }\n        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys\n        function OrdinaryOwnMetadataKeys(O, P) {\n            var provider = GetMetadataProvider(O, P, /*create*/ false);\n            if (!provider) {\n                return [];\n            }\n            return provider.OrdinaryOwnMetadataKeys(O, P);\n        }\n        // 6 ECMAScript Data Types and Values\n        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values\n        function Type(x) {\n            if (x === null)\n                return 1 /* Null */;\n            switch (typeof x) {\n                case \"undefined\": return 0 /* Undefined */;\n                case \"boolean\": return 2 /* Boolean */;\n                case \"string\": return 3 /* String */;\n                case \"symbol\": return 4 /* Symbol */;\n                case \"number\": return 5 /* Number */;\n                case \"object\": return x === null ? 1 /* Null */ : 6 /* Object */;\n                default: return 6 /* Object */;\n            }\n        }\n        // 6.1.1 The Undefined Type\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type\n        function IsUndefined(x) {\n            return x === undefined;\n        }\n        // 6.1.2 The Null Type\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type\n        function IsNull(x) {\n            return x === null;\n        }\n        // 6.1.5 The Symbol Type\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type\n        function IsSymbol(x) {\n            return typeof x === \"symbol\";\n        }\n        // 6.1.7 The Object Type\n        // https://tc39.github.io/ecma262/#sec-object-type\n        function IsObject(x) {\n            return typeof x === \"object\" ? x !== null : typeof x === \"function\";\n        }\n        // 7.1 Type Conversion\n        // https://tc39.github.io/ecma262/#sec-type-conversion\n        // 7.1.1 ToPrimitive(input [, PreferredType])\n        // https://tc39.github.io/ecma262/#sec-toprimitive\n        function ToPrimitive(input, PreferredType) {\n            switch (Type(input)) {\n                case 0 /* Undefined */: return input;\n                case 1 /* Null */: return input;\n                case 2 /* Boolean */: return input;\n                case 3 /* String */: return input;\n                case 4 /* Symbol */: return input;\n                case 5 /* Number */: return input;\n            }\n            var hint = PreferredType === 3 /* String */ ? \"string\" : PreferredType === 5 /* Number */ ? \"number\" : \"default\";\n            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);\n            if (exoticToPrim !== undefined) {\n                var result = exoticToPrim.call(input, hint);\n                if (IsObject(result))\n                    throw new TypeError();\n                return result;\n            }\n            return OrdinaryToPrimitive(input, hint === \"default\" ? \"number\" : hint);\n        }\n        // 7.1.1.1 OrdinaryToPrimitive(O, hint)\n        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive\n        function OrdinaryToPrimitive(O, hint) {\n            if (hint === \"string\") {\n                var toString_1 = O.toString;\n                if (IsCallable(toString_1)) {\n                    var result = toString_1.call(O);\n                    if (!IsObject(result))\n                        return result;\n                }\n                var valueOf = O.valueOf;\n                if (IsCallable(valueOf)) {\n                    var result = valueOf.call(O);\n                    if (!IsObject(result))\n                        return result;\n                }\n            }\n            else {\n                var valueOf = O.valueOf;\n                if (IsCallable(valueOf)) {\n                    var result = valueOf.call(O);\n                    if (!IsObject(result))\n                        return result;\n                }\n                var toString_2 = O.toString;\n                if (IsCallable(toString_2)) {\n                    var result = toString_2.call(O);\n                    if (!IsObject(result))\n                        return result;\n                }\n            }\n            throw new TypeError();\n        }\n        // 7.1.2 ToBoolean(argument)\n        // https://tc39.github.io/ecma262/2016/#sec-toboolean\n        function ToBoolean(argument) {\n            return !!argument;\n        }\n        // 7.1.12 ToString(argument)\n        // https://tc39.github.io/ecma262/#sec-tostring\n        function ToString(argument) {\n            return \"\" + argument;\n        }\n        // 7.1.14 ToPropertyKey(argument)\n        // https://tc39.github.io/ecma262/#sec-topropertykey\n        function ToPropertyKey(argument) {\n            var key = ToPrimitive(argument, 3 /* String */);\n            if (IsSymbol(key))\n                return key;\n            return ToString(key);\n        }\n        // 7.2 Testing and Comparison Operations\n        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations\n        // 7.2.2 IsArray(argument)\n        // https://tc39.github.io/ecma262/#sec-isarray\n        function IsArray(argument) {\n            return Array.isArray\n                ? Array.isArray(argument)\n                : argument instanceof Object\n                    ? argument instanceof Array\n                    : Object.prototype.toString.call(argument) === \"[object Array]\";\n        }\n        // 7.2.3 IsCallable(argument)\n        // https://tc39.github.io/ecma262/#sec-iscallable\n        function IsCallable(argument) {\n            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.\n            return typeof argument === \"function\";\n        }\n        // 7.2.4 IsConstructor(argument)\n        // https://tc39.github.io/ecma262/#sec-isconstructor\n        function IsConstructor(argument) {\n            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.\n            return typeof argument === \"function\";\n        }\n        // 7.2.7 IsPropertyKey(argument)\n        // https://tc39.github.io/ecma262/#sec-ispropertykey\n        function IsPropertyKey(argument) {\n            switch (Type(argument)) {\n                case 3 /* String */: return true;\n                case 4 /* Symbol */: return true;\n                default: return false;\n            }\n        }\n        function SameValueZero(x, y) {\n            return x === y || x !== x && y !== y;\n        }\n        // 7.3 Operations on Objects\n        // https://tc39.github.io/ecma262/#sec-operations-on-objects\n        // 7.3.9 GetMethod(V, P)\n        // https://tc39.github.io/ecma262/#sec-getmethod\n        function GetMethod(V, P) {\n            var func = V[P];\n            if (func === undefined || func === null)\n                return undefined;\n            if (!IsCallable(func))\n                throw new TypeError();\n            return func;\n        }\n        // 7.4 Operations on Iterator Objects\n        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects\n        function GetIterator(obj) {\n            var method = GetMethod(obj, iteratorSymbol);\n            if (!IsCallable(method))\n                throw new TypeError(); // from Call\n            var iterator = method.call(obj);\n            if (!IsObject(iterator))\n                throw new TypeError();\n            return iterator;\n        }\n        // 7.4.4 IteratorValue(iterResult)\n        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue\n        function IteratorValue(iterResult) {\n            return iterResult.value;\n        }\n        // 7.4.5 IteratorStep(iterator)\n        // https://tc39.github.io/ecma262/#sec-iteratorstep\n        function IteratorStep(iterator) {\n            var result = iterator.next();\n            return result.done ? false : result;\n        }\n        // 7.4.6 IteratorClose(iterator, completion)\n        // https://tc39.github.io/ecma262/#sec-iteratorclose\n        function IteratorClose(iterator) {\n            var f = iterator[\"return\"];\n            if (f)\n                f.call(iterator);\n        }\n        // 9.1 Ordinary Object Internal Methods and Internal Slots\n        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots\n        // 9.1.1.1 OrdinaryGetPrototypeOf(O)\n        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof\n        function OrdinaryGetPrototypeOf(O) {\n            var proto = Object.getPrototypeOf(O);\n            if (typeof O !== \"function\" || O === functionPrototype)\n                return proto;\n            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.\n            // Try to determine the superclass constructor. Compatible implementations\n            // must either set __proto__ on a subclass constructor to the superclass constructor,\n            // or ensure each class has a valid `constructor` property on its prototype that\n            // points back to the constructor.\n            // If this is not the same as Function.[[Prototype]], then this is definately inherited.\n            // This is the case when in ES6 or when using __proto__ in a compatible browser.\n            if (proto !== functionPrototype)\n                return proto;\n            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.\n            var prototype = O.prototype;\n            var prototypeProto = prototype && Object.getPrototypeOf(prototype);\n            if (prototypeProto == null || prototypeProto === Object.prototype)\n                return proto;\n            // If the constructor was not a function, then we cannot determine the heritage.\n            var constructor = prototypeProto.constructor;\n            if (typeof constructor !== \"function\")\n                return proto;\n            // If we have some kind of self-reference, then we cannot determine the heritage.\n            if (constructor === O)\n                return proto;\n            // we have a pretty good guess at the heritage.\n            return constructor;\n        }\n        // Global metadata registry\n        // - Allows `import \"reflect-metadata\"` and `import \"reflect-metadata/no-conflict\"` to interoperate.\n        // - Uses isolated metadata if `Reflect` is frozen before the registry can be installed.\n        /**\n         * Creates a registry used to allow multiple `reflect-metadata` providers.\n         */\n        function CreateMetadataRegistry() {\n            var fallback;\n            if (!IsUndefined(registrySymbol) &&\n                typeof root.Reflect !== \"undefined\" &&\n                !(registrySymbol in root.Reflect) &&\n                typeof root.Reflect.defineMetadata === \"function\") {\n                // interoperate with older version of `reflect-metadata` that did not support a registry.\n                fallback = CreateFallbackProvider(root.Reflect);\n            }\n            var first;\n            var second;\n            var rest;\n            var targetProviderMap = new _WeakMap();\n            var registry = {\n                registerProvider: registerProvider,\n                getProvider: getProvider,\n                setProvider: setProvider,\n            };\n            return registry;\n            function registerProvider(provider) {\n                if (!Object.isExtensible(registry)) {\n                    throw new Error(\"Cannot add provider to a frozen registry.\");\n                }\n                switch (true) {\n                    case fallback === provider: break;\n                    case IsUndefined(first):\n                        first = provider;\n                        break;\n                    case first === provider: break;\n                    case IsUndefined(second):\n                        second = provider;\n                        break;\n                    case second === provider: break;\n                    default:\n                        if (rest === undefined)\n                            rest = new _Set();\n                        rest.add(provider);\n                        break;\n                }\n            }\n            function getProviderNoCache(O, P) {\n                if (!IsUndefined(first)) {\n                    if (first.isProviderFor(O, P))\n                        return first;\n                    if (!IsUndefined(second)) {\n                        if (second.isProviderFor(O, P))\n                            return first;\n                        if (!IsUndefined(rest)) {\n                            var iterator = GetIterator(rest);\n                            while (true) {\n                                var next = IteratorStep(iterator);\n                                if (!next) {\n                                    return undefined;\n                                }\n                                var provider = IteratorValue(next);\n                                if (provider.isProviderFor(O, P)) {\n                                    IteratorClose(iterator);\n                                    return provider;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {\n                    return fallback;\n                }\n                return undefined;\n            }\n            function getProvider(O, P) {\n                var providerMap = targetProviderMap.get(O);\n                var provider;\n                if (!IsUndefined(providerMap)) {\n                    provider = providerMap.get(P);\n                }\n                if (!IsUndefined(provider)) {\n                    return provider;\n                }\n                provider = getProviderNoCache(O, P);\n                if (!IsUndefined(provider)) {\n                    if (IsUndefined(providerMap)) {\n                        providerMap = new _Map();\n                        targetProviderMap.set(O, providerMap);\n                    }\n                    providerMap.set(P, provider);\n                }\n                return provider;\n            }\n            function hasProvider(provider) {\n                if (IsUndefined(provider))\n                    throw new TypeError();\n                return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);\n            }\n            function setProvider(O, P, provider) {\n                if (!hasProvider(provider)) {\n                    throw new Error(\"Metadata provider not registered.\");\n                }\n                var existingProvider = getProvider(O, P);\n                if (existingProvider !== provider) {\n                    if (!IsUndefined(existingProvider)) {\n                        return false;\n                    }\n                    var providerMap = targetProviderMap.get(O);\n                    if (IsUndefined(providerMap)) {\n                        providerMap = new _Map();\n                        targetProviderMap.set(O, providerMap);\n                    }\n                    providerMap.set(P, provider);\n                }\n                return true;\n            }\n        }\n        /**\n         * Gets or creates the shared registry of metadata providers.\n         */\n        function GetOrCreateMetadataRegistry() {\n            var metadataRegistry;\n            if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {\n                metadataRegistry = root.Reflect[registrySymbol];\n            }\n            if (IsUndefined(metadataRegistry)) {\n                metadataRegistry = CreateMetadataRegistry();\n            }\n            if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {\n                Object.defineProperty(root.Reflect, registrySymbol, {\n                    enumerable: false,\n                    configurable: false,\n                    writable: false,\n                    value: metadataRegistry\n                });\n            }\n            return metadataRegistry;\n        }\n        function CreateMetadataProvider(registry) {\n            // [[Metadata]] internal slot\n            // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots\n            var metadata = new _WeakMap();\n            var provider = {\n                isProviderFor: function (O, P) {\n                    var targetMetadata = metadata.get(O);\n                    if (IsUndefined(targetMetadata))\n                        return false;\n                    return targetMetadata.has(P);\n                },\n                OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata,\n                OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata,\n                OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata,\n                OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys,\n                OrdinaryDeleteMetadata: OrdinaryDeleteMetadata,\n            };\n            metadataRegistry.registerProvider(provider);\n            return provider;\n            function GetOrCreateMetadataMap(O, P, Create) {\n                var targetMetadata = metadata.get(O);\n                var createdTargetMetadata = false;\n                if (IsUndefined(targetMetadata)) {\n                    if (!Create)\n                        return undefined;\n                    targetMetadata = new _Map();\n                    metadata.set(O, targetMetadata);\n                    createdTargetMetadata = true;\n                }\n                var metadataMap = targetMetadata.get(P);\n                if (IsUndefined(metadataMap)) {\n                    if (!Create)\n                        return undefined;\n                    metadataMap = new _Map();\n                    targetMetadata.set(P, metadataMap);\n                    if (!registry.setProvider(O, P, provider)) {\n                        targetMetadata.delete(P);\n                        if (createdTargetMetadata) {\n                            metadata.delete(O);\n                        }\n                        throw new Error(\"Wrong provider for target.\");\n                    }\n                }\n                return metadataMap;\n            }\n            // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)\n            // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata\n            function OrdinaryHasOwnMetadata(MetadataKey, O, P) {\n                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n                if (IsUndefined(metadataMap))\n                    return false;\n                return ToBoolean(metadataMap.has(MetadataKey));\n            }\n            // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)\n            // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata\n            function OrdinaryGetOwnMetadata(MetadataKey, O, P) {\n                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n                if (IsUndefined(metadataMap))\n                    return undefined;\n                return metadataMap.get(MetadataKey);\n            }\n            // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)\n            // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata\n            function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {\n                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);\n                metadataMap.set(MetadataKey, MetadataValue);\n            }\n            // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)\n            // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys\n            function OrdinaryOwnMetadataKeys(O, P) {\n                var keys = [];\n                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n                if (IsUndefined(metadataMap))\n                    return keys;\n                var keysObj = metadataMap.keys();\n                var iterator = GetIterator(keysObj);\n                var k = 0;\n                while (true) {\n                    var next = IteratorStep(iterator);\n                    if (!next) {\n                        keys.length = k;\n                        return keys;\n                    }\n                    var nextValue = IteratorValue(next);\n                    try {\n                        keys[k] = nextValue;\n                    }\n                    catch (e) {\n                        try {\n                            IteratorClose(iterator);\n                        }\n                        finally {\n                            throw e;\n                        }\n                    }\n                    k++;\n                }\n            }\n            function OrdinaryDeleteMetadata(MetadataKey, O, P) {\n                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n                if (IsUndefined(metadataMap))\n                    return false;\n                if (!metadataMap.delete(MetadataKey))\n                    return false;\n                if (metadataMap.size === 0) {\n                    var targetMetadata = metadata.get(O);\n                    if (!IsUndefined(targetMetadata)) {\n                        targetMetadata.delete(P);\n                        if (targetMetadata.size === 0) {\n                            metadata.delete(targetMetadata);\n                        }\n                    }\n                }\n                return true;\n            }\n        }\n        function CreateFallbackProvider(reflect) {\n            var defineMetadata = reflect.defineMetadata, hasOwnMetadata = reflect.hasOwnMetadata, getOwnMetadata = reflect.getOwnMetadata, getOwnMetadataKeys = reflect.getOwnMetadataKeys, deleteMetadata = reflect.deleteMetadata;\n            var metadataOwner = new _WeakMap();\n            var provider = {\n                isProviderFor: function (O, P) {\n                    var metadataPropertySet = metadataOwner.get(O);\n                    if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P)) {\n                        return true;\n                    }\n                    if (getOwnMetadataKeys(O, P).length) {\n                        if (IsUndefined(metadataPropertySet)) {\n                            metadataPropertySet = new _Set();\n                            metadataOwner.set(O, metadataPropertySet);\n                        }\n                        metadataPropertySet.add(P);\n                        return true;\n                    }\n                    return false;\n                },\n                OrdinaryDefineOwnMetadata: defineMetadata,\n                OrdinaryHasOwnMetadata: hasOwnMetadata,\n                OrdinaryGetOwnMetadata: getOwnMetadata,\n                OrdinaryOwnMetadataKeys: getOwnMetadataKeys,\n                OrdinaryDeleteMetadata: deleteMetadata,\n            };\n            return provider;\n        }\n        /**\n         * Gets the metadata provider for an object. If the object has no metadata provider and this is for a create operation,\n         * then this module's metadata provider is assigned to the object.\n         */\n        function GetMetadataProvider(O, P, Create) {\n            var registeredProvider = metadataRegistry.getProvider(O, P);\n            if (!IsUndefined(registeredProvider)) {\n                return registeredProvider;\n            }\n            if (Create) {\n                if (metadataRegistry.setProvider(O, P, metadataProvider)) {\n                    return metadataProvider;\n                }\n                throw new Error(\"Illegal state.\");\n            }\n            return undefined;\n        }\n        // naive Map shim\n        function CreateMapPolyfill() {\n            var cacheSentinel = {};\n            var arraySentinel = [];\n            var MapIterator = /** @class */ (function () {\n                function MapIterator(keys, values, selector) {\n                    this._index = 0;\n                    this._keys = keys;\n                    this._values = values;\n                    this._selector = selector;\n                }\n                MapIterator.prototype[\"@@iterator\"] = function () { return this; };\n                MapIterator.prototype[iteratorSymbol] = function () { return this; };\n                MapIterator.prototype.next = function () {\n                    var index = this._index;\n                    if (index >= 0 && index < this._keys.length) {\n                        var result = this._selector(this._keys[index], this._values[index]);\n                        if (index + 1 >= this._keys.length) {\n                            this._index = -1;\n                            this._keys = arraySentinel;\n                            this._values = arraySentinel;\n                        }\n                        else {\n                            this._index++;\n                        }\n                        return { value: result, done: false };\n                    }\n                    return { value: undefined, done: true };\n                };\n                MapIterator.prototype.throw = function (error) {\n                    if (this._index >= 0) {\n                        this._index = -1;\n                        this._keys = arraySentinel;\n                        this._values = arraySentinel;\n                    }\n                    throw error;\n                };\n                MapIterator.prototype.return = function (value) {\n                    if (this._index >= 0) {\n                        this._index = -1;\n                        this._keys = arraySentinel;\n                        this._values = arraySentinel;\n                    }\n                    return { value: value, done: true };\n                };\n                return MapIterator;\n            }());\n            var Map = /** @class */ (function () {\n                function Map() {\n                    this._keys = [];\n                    this._values = [];\n                    this._cacheKey = cacheSentinel;\n                    this._cacheIndex = -2;\n                }\n                Object.defineProperty(Map.prototype, \"size\", {\n                    get: function () { return this._keys.length; },\n                    enumerable: true,\n                    configurable: true\n                });\n                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };\n                Map.prototype.get = function (key) {\n                    var index = this._find(key, /*insert*/ false);\n                    return index >= 0 ? this._values[index] : undefined;\n                };\n                Map.prototype.set = function (key, value) {\n                    var index = this._find(key, /*insert*/ true);\n                    this._values[index] = value;\n                    return this;\n                };\n                Map.prototype.delete = function (key) {\n                    var index = this._find(key, /*insert*/ false);\n                    if (index >= 0) {\n                        var size = this._keys.length;\n                        for (var i = index + 1; i < size; i++) {\n                            this._keys[i - 1] = this._keys[i];\n                            this._values[i - 1] = this._values[i];\n                        }\n                        this._keys.length--;\n                        this._values.length--;\n                        if (SameValueZero(key, this._cacheKey)) {\n                            this._cacheKey = cacheSentinel;\n                            this._cacheIndex = -2;\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                Map.prototype.clear = function () {\n                    this._keys.length = 0;\n                    this._values.length = 0;\n                    this._cacheKey = cacheSentinel;\n                    this._cacheIndex = -2;\n                };\n                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };\n                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };\n                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };\n                Map.prototype[\"@@iterator\"] = function () { return this.entries(); };\n                Map.prototype[iteratorSymbol] = function () { return this.entries(); };\n                Map.prototype._find = function (key, insert) {\n                    if (!SameValueZero(this._cacheKey, key)) {\n                        this._cacheIndex = -1;\n                        for (var i = 0; i < this._keys.length; i++) {\n                            if (SameValueZero(this._keys[i], key)) {\n                                this._cacheIndex = i;\n                                break;\n                            }\n                        }\n                    }\n                    if (this._cacheIndex < 0 && insert) {\n                        this._cacheIndex = this._keys.length;\n                        this._keys.push(key);\n                        this._values.push(undefined);\n                    }\n                    return this._cacheIndex;\n                };\n                return Map;\n            }());\n            return Map;\n            function getKey(key, _) {\n                return key;\n            }\n            function getValue(_, value) {\n                return value;\n            }\n            function getEntry(key, value) {\n                return [key, value];\n            }\n        }\n        // naive Set shim\n        function CreateSetPolyfill() {\n            var Set = /** @class */ (function () {\n                function Set() {\n                    this._map = new _Map();\n                }\n                Object.defineProperty(Set.prototype, \"size\", {\n                    get: function () { return this._map.size; },\n                    enumerable: true,\n                    configurable: true\n                });\n                Set.prototype.has = function (value) { return this._map.has(value); };\n                Set.prototype.add = function (value) { return this._map.set(value, value), this; };\n                Set.prototype.delete = function (value) { return this._map.delete(value); };\n                Set.prototype.clear = function () { this._map.clear(); };\n                Set.prototype.keys = function () { return this._map.keys(); };\n                Set.prototype.values = function () { return this._map.keys(); };\n                Set.prototype.entries = function () { return this._map.entries(); };\n                Set.prototype[\"@@iterator\"] = function () { return this.keys(); };\n                Set.prototype[iteratorSymbol] = function () { return this.keys(); };\n                return Set;\n            }());\n            return Set;\n        }\n        // naive WeakMap shim\n        function CreateWeakMapPolyfill() {\n            var UUID_SIZE = 16;\n            var keys = HashMap.create();\n            var rootKey = CreateUniqueKey();\n            return /** @class */ (function () {\n                function WeakMap() {\n                    this._key = CreateUniqueKey();\n                }\n                WeakMap.prototype.has = function (target) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                    return table !== undefined ? HashMap.has(table, this._key) : false;\n                };\n                WeakMap.prototype.get = function (target) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                    return table !== undefined ? HashMap.get(table, this._key) : undefined;\n                };\n                WeakMap.prototype.set = function (target, value) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);\n                    table[this._key] = value;\n                    return this;\n                };\n                WeakMap.prototype.delete = function (target) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                    return table !== undefined ? delete table[this._key] : false;\n                };\n                WeakMap.prototype.clear = function () {\n                    // NOTE: not a real clear, just makes the previous data unreachable\n                    this._key = CreateUniqueKey();\n                };\n                return WeakMap;\n            }());\n            function CreateUniqueKey() {\n                var key;\n                do\n                    key = \"@@WeakMap@@\" + CreateUUID();\n                while (HashMap.has(keys, key));\n                keys[key] = true;\n                return key;\n            }\n            function GetOrCreateWeakMapTable(target, create) {\n                if (!hasOwn.call(target, rootKey)) {\n                    if (!create)\n                        return undefined;\n                    Object.defineProperty(target, rootKey, { value: HashMap.create() });\n                }\n                return target[rootKey];\n            }\n            function FillRandomBytes(buffer, size) {\n                for (var i = 0; i < size; ++i)\n                    buffer[i] = Math.random() * 0xff | 0;\n                return buffer;\n            }\n            function GenRandomBytes(size) {\n                if (typeof Uint8Array === \"function\") {\n                    var array = new Uint8Array(size);\n                    if (typeof crypto !== \"undefined\") {\n                        crypto.getRandomValues(array);\n                    }\n                    else if (typeof msCrypto !== \"undefined\") {\n                        msCrypto.getRandomValues(array);\n                    }\n                    else {\n                        FillRandomBytes(array, size);\n                    }\n                    return array;\n                }\n                return FillRandomBytes(new Array(size), size);\n            }\n            function CreateUUID() {\n                var data = GenRandomBytes(UUID_SIZE);\n                // mark as random - RFC 4122  4.4\n                data[6] = data[6] & 0x4f | 0x40;\n                data[8] = data[8] & 0xbf | 0x80;\n                var result = \"\";\n                for (var offset = 0; offset < UUID_SIZE; ++offset) {\n                    var byte = data[offset];\n                    if (offset === 4 || offset === 6 || offset === 8)\n                        result += \"-\";\n                    if (byte < 16)\n                        result += \"0\";\n                    result += byte.toString(16).toLowerCase();\n                }\n                return result;\n            }\n        }\n        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.\n        function MakeDictionary(obj) {\n            obj.__ = undefined;\n            delete obj.__;\n            return obj;\n        }\n    });\n})(Reflect || (Reflect = {}));\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { container } from \"../Core/DependencyInjection/container-config\";\r\nimport { IReactiveValidatorService } from \"../Core/Interfaces/IReactiveValidatorService\";\r\nimport {ContainerTypes } from \"../Core/Types/ContainerTypes\";\r\n\r\nconst formElement = document.getElementById(\"registerForm\") as HTMLFormElement;\r\nconst service = container.get<IReactiveValidatorService>(ContainerTypes.ReactiveValidatorService);\r\nconst group = service.registerForm(formElement);\r\n\r\nformElement.addEventListener(\"submit\", async (e) => {\r\n  e.preventDefault();\r\n  const isValid = await service.validateForm(group);\r\n  console.log(\"Form valid?\", isValid);\r\n});\r\n"],"names":[],"sourceRoot":""}